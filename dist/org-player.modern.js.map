{"version":3,"file":"org-player.modern.js","sources":["../src/envelope.ts","../src/constants.ts","../src/stream.ts","../src/helpers.ts","../src/song-reader.ts","../src/org-player.ts"],"sourcesContent":["import { DRUM_ENVELOPE_CUTOFF_SAMPLES, ENVELOPE_CUTOFF_SAMPLES, FADE_IN_SAMPLES, USE_ENVELOPE } from \"./constants\";\r\n\r\nexport const getFadeIn = (absoluteSamples: number): number => {\r\n  if (absoluteSamples > FADE_IN_SAMPLES) return 1.0;\r\n  else return absoluteSamples / FADE_IN_SAMPLES;\r\n};\r\n\r\n// TODO: These are not sample-rate independent!\r\n// Remove some crackling with a really small envelope (100 samples)\r\nexport const getAttackEnvelope = (isDrum: boolean, samples: number): number => {\r\n  if (!USE_ENVELOPE) return 1;\r\n  const cutoff = isDrum ? DRUM_ENVELOPE_CUTOFF_SAMPLES : ENVELOPE_CUTOFF_SAMPLES;\r\n  if (samples > cutoff) return 1.0;\r\n  else return samples / cutoff;\r\n};\r\n\r\nexport const getReleaseEnvelope = (isDrum: boolean, samples: number, length: number): number => {\r\n  return getAttackEnvelope(isDrum, length - samples);\r\n};\r\n","// Sample rate drums are recorded in - in hz.\r\nexport const DRUM_SAMPLE_RATE = 22050;\r\n\r\n// Number of different channels in the file.\r\nexport const CHANNEL_COUNT = 16;\r\n\r\n// Size of an entry in the wavetable.\r\nexport const WAVETABLE_ENTRY_SIZE = 256;\r\n\r\n// The \"PI\" flag on an instrument sets the length to\r\n// Probably short for 'Pizzacato.'\r\nexport const PI_NOTE_LENGTH_SAMPLES = 1024; // TODO: This is wrong: 'PI' determines how many periods of the wave play.\r\nexport const PITCH_BEND_NORMALIZATION_FACTOR = 1000;\r\nexport const CHANNEL_PRESCALE = 0.5;\r\n\r\nexport const ENVELOPE_CUTOFF_SAMPLES = 50;\r\nexport const DRUM_ENVELOPE_CUTOFF_SAMPLES = 15;\r\n\r\nexport const FADE_IN_SAMPLES = 1000;\r\n\r\nexport const PRE_SCALE_TRACK_VOLUME = 1 / 3;\r\n\r\nexport const USE_ENVELOPE = true;\r\n","import { WAVETABLE_ENTRY_SIZE } from \"./constants\";\r\n\r\n/** Helper array \"stream\" wrapper, for reading the binary .org files. */\r\nexport class BufferStream {\r\n  private readonly data: Uint8Array;\r\n  private readonly view: DataView;\r\n  private position: number;\r\n\r\n  constructor(buffer: Uint8Array) {\r\n    this.data = buffer;\r\n    this.view = new DataView(buffer.buffer);\r\n    this.position = 0;\r\n  }\r\n\r\n  next = (reader: (position: number) => number, size: 1 | 2 | 4) => () => {\r\n    const value = reader(this.position);\r\n    this.position += size;\r\n    return value;\r\n  };\r\n\r\n  /** Skips the next n bytes in the stream. */\r\n  skip = (bytes: number) => (this.position += bytes);\r\n\r\n  /** Reads the next unsigned byte from the stream. */\r\n  nextByte = this.next((pos) => this.view.getUint8(pos), 1);\r\n\r\n  /** Reads the next signed byte from the stream. */\r\n  nextSignedByte = this.next((pos) => this.view.getInt8(pos), 1);\r\n\r\n  /** Reads the next 16 bit integer from the stream, little endian. */\r\n  nextShort = this.next((pos) => this.view.getUint16(pos, true), 2);\r\n\r\n  /** Reads the next signed 16 bit integer from the stream, little endian. */\r\n  nextSignedShort = this.next((pos) => this.view.getInt16(pos, true), 2);\r\n\r\n  /** Reads a big endian signed 16 bit integer from the stream. */\r\n  nextBigEndianSignedShort = this.next((pos) => this.view.getInt16(pos, false), 2);\r\n\r\n  /** Reads the next 32 bit integer from the stream, little endian. */\r\n  nextInt = this.next((pos) => this.view.getInt32(pos, true), 4);\r\n\r\n  /** Reads a whole wavetable from the stream. */\r\n  nextWavetable = (): number[] => {\r\n    const samples = [];\r\n\r\n    for (let i = 0; i < WAVETABLE_ENTRY_SIZE; i++) {\r\n      samples.push(this.nextSignedByte());\r\n    }\r\n\r\n    return samples;\r\n  };\r\n\r\n  /** Reads the whole stream as a drum sample. */\r\n  asDrumSample = (): number[] => {\r\n    const samples = [];\r\n    while (this.position < this.data.length) {\r\n      samples.push(this.nextBigEndianSignedShort());\r\n    }\r\n    return samples;\r\n  };\r\n}\r\n","import { BufferStream } from \"./stream\";\r\n\r\n/** Helper to clamp a value within [-1, 1]. */\r\nexport const clamp = (v: number): number => {\r\n  if (v > 1) {\r\n    return 1;\r\n  } else if (v < -1) {\r\n    return -1;\r\n  } else {\r\n    return v;\r\n  }\r\n};\r\n\r\n/** Helper which takes a base64encoded string, and parses it to a byte buffer. */\r\nexport const base64ToByteBuffer = (base64EncodedData: string) => {\r\n  const decoded = atob(base64EncodedData);\r\n  const buffer = new Uint8Array(decoded.length);\r\n  for (let i = 0; i < decoded.length; i++) {\r\n    buffer[i] = decoded.charCodeAt(i);\r\n  }\r\n  return buffer;\r\n};\r\n\r\nexport const parseWavetable = (encodedWavetable: Uint8Array) => {\r\n  const instruments = [];\r\n  const stream = new BufferStream(encodedWavetable);\r\n  for (let i = 0; i < 100; i++) {\r\n    const wavetableInstrument = stream.nextWavetable();\r\n    instruments.push(wavetableInstrument.map((sbyte) => (1.0 * sbyte) / 256.0)); // FIXME: Off-by-one here because this is +127/-128?\r\n  }\r\n  return instruments;\r\n};\r\n\r\nexport const parseDrum = (encodedDrumSample: Uint8Array) => {\r\n  const stream = new BufferStream(encodedDrumSample);\r\n  return stream.asDrumSample().map((short) => (1.0 * short) / 32767.0); // See above: Off by one? a\r\n};\r\n\r\n/** Helper to map from a beat number to a sample number, provided a wait value. */\r\nexport const beatToSample = (wait: number, sampleRate: number) => (beat: number) => {\r\n  const samplesPerMsec = Math.floor(sampleRate / 1000);\r\n  const samplesPerBeat = samplesPerMsec * wait;\r\n  return beat * samplesPerBeat;\r\n};\r\n","import { CHANNEL_COUNT, PITCH_BEND_NORMALIZATION_FACTOR } from \"./constants\";\r\nimport { beatToSample, parseDrum, parseWavetable } from \"./helpers\";\r\nimport { BufferStream } from \"./stream\";\r\nimport { Channel, OrganyaFile } from \"./types\";\r\nimport { WaveTable } from \"./wavetable\";\r\n\r\n// Accurate volume and pan from http://rnhart.net/orgmaker, NXEngine-Evo\r\nconst FrequenciesByNote = [262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494];\r\nconst OctavePeriod = [32, 64, 64, 128, 128, 128, 128, 128];\r\nconst WaveLengthsByOctave = [256, 256, 128, 128, 64, 32, 16, 8];\r\nconst Pan = [0, 43, 86, 129, 172, 215, 256, 297, 340, 383, 426, 469, 512];\r\n\r\nconst getAccurateVolumeScaleFactor = (noteVolume: number): number => {\r\n  // i.cur_vol = powf(10.0, ((event.volume - 255) * 8) / 2000.0) / 128.0;\r\n  const relativeVolume = noteVolume - 255;\r\n  return Math.pow(10, (relativeVolume * 8) / 2000);\r\n};\r\n\r\nconst getAccuratePanningScaleFactor = (pan: number): [number, number] => {\r\n  const panIndex = Math.floor(Math.min(12, Math.max(0, pan)));\r\n  const panValue = (Pan[panIndex] - 256) * 10;\r\n  let left = 1;\r\n  let right = 1;\r\n\r\n  if (panValue < 0) {\r\n    right = Math.pow(10, panValue / 2000);\r\n  } else if (pan > 0) {\r\n    left = Math.pow(10, -panValue / 2000);\r\n  }\r\n  return [left, right];\r\n};\r\n\r\n/**\r\n * Reader which reads a .org file stream in to a parsed song.\r\n * @example `(new SongReader()).read(songData)`;\r\n */\r\nexport class SongReader {\r\n  private readonly _wavetable: number[][];\r\n  private readonly _drums: number[][];\r\n\r\n  private readonly useAlgorithmicPitch = true;\r\n\r\n  constructor(private readonly _sampleRate: number, waveData: WaveTable) {\r\n    this._wavetable = parseWavetable(waveData.WAVE100);\r\n    this._drums = waveData.DRUMS.map(parseDrum);\r\n  }\r\n\r\n  parseChannelData = (stream: BufferStream): Channel => {\r\n    const voice = stream.nextSignedShort();\r\n    const instrument = stream.nextByte();\r\n    const pi = stream.nextByte() != 0;\r\n    const noteCount = stream.nextShort();\r\n\r\n    return { voice, instrument, pi, noteCount, notes: [], loopNote: 0 };\r\n  };\r\n\r\n  parse = (songData: Uint8Array): OrganyaFile => {\r\n    const stream = new BufferStream(songData);\r\n    const drumLengths = this._drums.map((a) => a.length);\r\n\r\n    stream.skip(6); // Header\r\n\r\n    // Wait in msec between beats.\r\n    const wait = stream.nextShort();\r\n\r\n    const sampleTime = beatToSample(wait, this._sampleRate);\r\n    const beatLengthSamples = sampleTime(1);\r\n\r\n    stream.skip(2); // Time signature isn't important for playback.\r\n\r\n    const songStart = sampleTime(stream.nextInt());\r\n    const songEnd = sampleTime(stream.nextInt());\r\n\r\n    const channelData: Channel[] = [];\r\n\r\n    // Read all 16 instrument blocks\r\n    for (let i = 0; i < CHANNEL_COUNT; i++) {\r\n      channelData.push(this.parseChannelData(stream));\r\n    }\r\n\r\n    // Read each of the note blocks for every instrument.\r\n    for (let i = 0; i < CHANNEL_COUNT; i++) {\r\n      // Org format interprets 0xff as what was on the previous note.\r\n      let lastPitch = 95;\r\n      let lastLength = 1;\r\n      let lastVolume = 254;\r\n      let lastPan = 6;\r\n\r\n      // Beat: uint32, start of the note, in beats.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        const beat = stream.nextInt(); // # of beat in the song.\r\n        channelData[i].notes.push({ start: Math.floor(sampleTime(beat)), end: 0, leftVolume: 0, rightVolume: 0, pan: 0, pitch: 0, sampleAdvance: 0, volume: 0, length: 0 });\r\n      }\r\n\r\n      // Pitch\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let pitch = stream.nextByte();\r\n        if (pitch == 0xff) pitch = lastPitch;\r\n        lastPitch = pitch;\r\n        channelData[i].notes[n].pitch = pitch;\r\n      }\r\n\r\n      // Length: uint8, 0-254\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let length = stream.nextByte();\r\n        if (length == 0xff) length = lastLength;\r\n        lastLength = length;\r\n        channelData[i].notes[n].end = channelData[i].notes[n].start + sampleTime(length);\r\n        channelData[i].notes[n].length = length;\r\n      }\r\n\r\n      // Volume: uint8, 0-254.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let volume = stream.nextByte();\r\n        if (volume == 0xff) volume = lastVolume;\r\n        lastVolume = volume;\r\n        channelData[i].notes[n].volume = volume;\r\n      }\r\n\r\n      // Pan: uint8, 0-12.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let pan = stream.nextByte();\r\n        if (pan == 0xff) pan = lastPan;\r\n        lastPan = pan;\r\n        channelData[i].notes[n].pan = pan;\r\n      }\r\n\r\n      // Do some pre-calculations here - get the octave / point speed for the note.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        const note = channelData[i].notes[n];\r\n        const pitch = note.pitch;\r\n        const isDrum = i >= 8;\r\n\r\n        const pitchBend = channelData[i].voice / PITCH_BEND_NORMALIZATION_FACTOR;\r\n\r\n        let freq = 0;\r\n        // Note: frequency algorithm & lookups referenced from: https://github.com/nxengine/nxengine-evo/blob/master/src/sound/Organya.cpp\r\n        if (this.useAlgorithmicPitch) {\r\n          // Algorithmi\r\n          freq = Math.pow(2, (pitch + pitchBend + 155.376) / 12);\r\n        } else {\r\n          // TODO: Figure out what NxEngine's doing here. This is supposed to be \"more accurate\".\r\n          const note = Math.floor(pitch % 12);\r\n          const octave = Math.floor(pitch / 12);\r\n          freq = FrequenciesByNote[note] * OctavePeriod[octave] + (channelData[i].voice - 1000);\r\n        }\r\n\r\n        const speed = freq / this._sampleRate;\r\n\r\n        const [panLeft, panRight] = getAccuratePanningScaleFactor(note.pan);\r\n        const volumeScale = getAccurateVolumeScaleFactor(note.volume);\r\n\r\n        note.leftVolume = panLeft * volumeScale;\r\n        note.rightVolume = panRight * volumeScale;\r\n\r\n        note.sampleAdvance = speed;\r\n\r\n        // And set the correct note length for drum notes.\r\n        if (isDrum) {\r\n          // Also referencing NxEngine here: Drum frequencies are different than instrument ones in a way that's not obvious.\r\n          // And drums don't care about the length? (???)\r\n          note.sampleAdvance = (note.pitch * 800 + 100) / this._sampleRate;\r\n\r\n          // Clip drum length.\r\n          note.end = Math.floor(note.start + Math.min(drumLengths[channelData[i].instrument] / note.sampleAdvance, (beatLengthSamples * note.length) / note.sampleAdvance));\r\n\r\n          // Kill the note early if there's another drum before the end of this one.\r\n          const nextNote = channelData[i].notes[n + 1];\r\n          if (!!nextNote) {\r\n            note.end = Math.floor(Math.min(note.end, nextNote.start - 1));\r\n          }\r\n        }\r\n\r\n        if (channelData[i].pi) {\r\n          // Sourced from: http://rnhart.net/orgmaker/vol-pan-pi.htm & NXEngine-Evo\r\n          const octave = Math.floor(pitch / 12);\r\n          const noteLengthSamples = (octave + 1) * 4 * WaveLengthsByOctave[octave];\r\n          note.end = note.start + noteLengthSamples;\r\n        }\r\n      }\r\n\r\n      channelData[i].notes.sort((l, r) => l.start - r.start); // Sanity check just in case they're not sorted.\r\n\r\n      // Now, calculate loop notes for each of the instruments. When the song loops, it'll set this as the active one.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        const loopNote = channelData[i].notes.findIndex((n) => n.end > songStart);\r\n\r\n        if (loopNote != -1) {\r\n          // Check if we loop _within_ a note. If we do, then play that note.\r\n          channelData[i].loopNote = loopNote;\r\n        } else {\r\n          channelData[i].loopNote = 0;\r\n        }\r\n      }\r\n    }\r\n    return { startSamples: songStart, endSamples: songEnd, channels: channelData, sampleRate: this._sampleRate, drums: this._drums, wavetable: this._wavetable };\r\n  };\r\n}\r\n","import { PI_NOTE_LENGTH_SAMPLES, PRE_SCALE_TRACK_VOLUME as PRE_SCALE_CHANNEL_VOLUME } from \"./constants\";\r\nimport { getAttackEnvelope, getFadeIn, getReleaseEnvelope } from \"./envelope\";\r\nimport { clamp } from \"./helpers\";\r\nimport { SongReader } from \"./song-reader\";\r\nimport { OrganyaFile } from \"./types\";\r\nimport { WaveTable } from \"./wavetable\";\r\n\r\ntype OutputStep = [number, number];\r\n\r\ntype InstrumentState = {\r\n  noteIndex: number;\r\n  wavetableOffset: number;\r\n  samplesPlayed: number;\r\n};\r\n\r\n/**\r\n * .ORG file player. \r\n */\r\nexport class OrganyaPlayer {\r\n  private readonly song: OrganyaFile;\r\n\r\n  // GC optimiztion: Preallocate these to ensure we don't create garbage each step.w\r\n  // (Trying to do all I can to prevent stutter on mobile.)\r\n  private readonly stepBuffer: OutputStep = [0, 0];\r\n  private readonly channelBuffer: OutputStep = [0, 0];\r\n\r\n  private sample: number;\r\n  private readonly state: InstrumentState[];\r\n\r\n  /**\r\n   * Creates a new Organya file player with the given .org file data and sample rate.\r\n   */\r\n  constructor(songData: Uint8Array, private readonly waveData: WaveTable, private readonly sampleRate: number) {\r\n    const songReader = new SongReader(sampleRate, waveData);\r\n\r\n    // TODO: Actually, pass in a Song.\r\n    this.song = songReader.parse(songData);\r\n\r\n    this.sample = -4000; // HACK: Start a bit before the song actually does, to make sure that the browser doesn't stutter.\r\n    this.state = [];\r\n    for (let i = 0; i < 16; i++) {\r\n      this.state.push({\r\n        noteIndex: 0,\r\n        wavetableOffset: 0,\r\n        samplesPlayed: 0,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates the provided number of samples, outputting them into a left / right array.\r\n   */\r\n  run = (stepCount: number, left: Float32Array, right: Float32Array) => {\r\n    const buffer = [new Float32Array(stepCount), new Float32Array(stepCount)];\r\n\r\n    for (let i = 0; i < stepCount; i++) {\r\n      this.step(this.stepBuffer);\r\n      left[i] = this.stepBuffer[0];\r\n      right[i] = this.stepBuffer[1];\r\n    }\r\n\r\n    return buffer;\r\n  };\r\n\r\n  step = (stepBuffer: OutputStep) => {\r\n    let left = 0;\r\n    let right = 0;\r\n\r\n    // Update each instrument.\r\n    for (let i = 0; i < 16; i++) {\r\n      this.stepChannel(i, this.channelBuffer);\r\n      left += this.channelBuffer[0] * PRE_SCALE_CHANNEL_VOLUME;\r\n      right += this.channelBuffer[1] * PRE_SCALE_CHANNEL_VOLUME;\r\n    }\r\n\r\n    this.sample++;\r\n\r\n    // Have we looped around?\r\n    if (this.sample >= this.song.endSamples) {\r\n      for (let i = 0; i < 16; i++) {\r\n        // Reset the sample count & the player states.\r\n        this.state[i] = {\r\n          noteIndex: this.song.channels[i].loopNote,\r\n          wavetableOffset: 0,\r\n          samplesPlayed: 0,\r\n        };\r\n      }\r\n\r\n      // And rewind to the loop point.\r\n      this.sample = this.song.startSamples;\r\n    }\r\n    const fadeIn = getFadeIn(this.sample);\r\n\r\n    stepBuffer[0] = clamp(left) * fadeIn;\r\n    stepBuffer[1] = clamp(right) * fadeIn;\r\n  };\r\n\r\n  stepChannel = (instrumentIndex: number, channelBuffer: OutputStep) => {\r\n    const instrument = this.song.channels[instrumentIndex];\r\n    const noteIndex = this.state[instrumentIndex].noteIndex;\r\n    const isDrum = instrumentIndex >= 8;\r\n\r\n    const note = noteIndex >= instrument.notes.length ? null : instrument.notes[noteIndex];\r\n\r\n    let left = 0;\r\n    let right = 0;\r\n\r\n    if (note != null && this.sample > note.start) {\r\n      const { pi } = instrument;\r\n      const voiceIndex = instrument.instrument;\r\n\r\n      // Play sample.\r\n      if (!pi || this.state[instrumentIndex].samplesPlayed < PI_NOTE_LENGTH_SAMPLES) {\r\n        const sample = !isDrum ? this.song.wavetable[voiceIndex] : this.song.drums[voiceIndex];\r\n        const absoluteSamplePosition = this.state[instrumentIndex].wavetableOffset + note.sampleAdvance;\r\n\r\n        const wavetableSample = this.getSample(sample, absoluteSamplePosition);\r\n\r\n        left = wavetableSample * note.leftVolume;\r\n        right = wavetableSample * note.rightVolume;\r\n\r\n        this.state[instrumentIndex].wavetableOffset = absoluteSamplePosition;\r\n        this.state[instrumentIndex].samplesPlayed++;\r\n\r\n        // Apply a tiny envelope to the instruments, to prevent crackling.\r\n        const envelope =\r\n          getAttackEnvelope(isDrum, this.state[instrumentIndex].samplesPlayed) * getReleaseEnvelope(isDrum, this.state[instrumentIndex].samplesPlayed, note.end - note.start);\r\n\r\n        left *= envelope;\r\n        right *= envelope;\r\n      }\r\n    }\r\n\r\n    // Advance the note index if it's finished playing.\r\n    if (note != null && this.sample >= note.end) {\r\n      this.state[instrumentIndex].wavetableOffset = 0;\r\n      this.state[instrumentIndex].samplesPlayed = 0;\r\n      this.state[instrumentIndex].noteIndex++;\r\n    }\r\n\r\n    channelBuffer[0] = left;\r\n    channelBuffer[1] = right;\r\n  };\r\n/**\r\n   * Reads a single sample from a wavetable or drum sound buffer.\r\n   *\r\n   * @param wavetableOrDrum The sound to read the sample from.\r\n   * @param offset The offset in samples of the sample to read.\r\n   * @returns Returns the sample value (linearly interpolated.)\r\n   */\r\n  getSample = (wavetableOrDrum: number[], offset: number) => {\r\n    // get the lerped value b/w the two samples.\r\n    const v0 = wavetableOrDrum[Math.floor(offset) % wavetableOrDrum.length];\r\n    const v1 = wavetableOrDrum[Math.ceil(offset) % wavetableOrDrum.length];\r\n    const t = offset - Math.floor(offset);\r\n    return v0 + t * (v1 - v0);\r\n  };\r\n}\r\n"],"names":["getAttackEnvelope","isDrum","samples","cutoff","BufferStream","constructor","buffer","data","view","position","next","reader","size","value","this","skip","bytes","nextByte","pos","getUint8","nextSignedByte","getInt8","nextShort","getUint16","nextSignedShort","getInt16","nextBigEndianSignedShort","nextInt","getInt32","nextWavetable","i","push","asDrumSample","length","DataView","clamp","v","parseDrum","encodedDrumSample","map","short","FrequenciesByNote","OctavePeriod","WaveLengthsByOctave","Pan","getAccuratePanningScaleFactor","pan","panIndex","Math","floor","min","max","panValue","left","right","pow","SongReader","_sampleRate","waveData","_wavetable","_drums","useAlgorithmicPitch","parseChannelData","stream","voice","instrument","pi","noteCount","notes","loopNote","parse","songData","drumLengths","a","sampleTime","wait","sampleRate","beat","beatLengthSamples","songStart","songEnd","channelData","lastPitch","lastLength","lastVolume","lastPan","n","start","end","leftVolume","rightVolume","pitch","sampleAdvance","volume","note","pitchBend","freq","octave","speed","panLeft","panRight","volumeScale","nextNote","sort","l","r","findIndex","startSamples","endSamples","channels","drums","wavetable","encodedWavetable","instruments","wavetableInstrument","sbyte","parseWavetable","WAVE100","DRUMS","OrganyaPlayer","song","stepBuffer","channelBuffer","sample","state","run","stepCount","Float32Array","step","stepChannel","noteIndex","wavetableOffset","samplesPlayed","fadeIn","absoluteSamples","instrumentIndex","voiceIndex","absoluteSamplePosition","wavetableSample","getSample","envelope","getReleaseEnvelope","wavetableOrDrum","offset","v0","v1","ceil","songReader"],"mappings":"MASaA,EAAoB,CAACC,EAAiBC,KAEjD,MAAMC,EAASF,ECK2B,GADL,GDHrC,OAAIC,EAAUC,IACFD,EAAUC,SEVXC,EAKXC,YAAYC,QAJKC,iBACAC,iBACTC,qBAQRC,KAAO,CAACC,EAAsCC,IAAoB,KAChE,MAAMC,EAAQF,EAAOG,KAAKL,UAE1B,OADAK,KAAKL,UAAYG,EACVC,QAITE,KAAQC,GAAmBF,KAAKL,UAAYO,OAG5CC,SAAWH,KAAKJ,KAAMQ,GAAQJ,KAAKN,KAAKW,SAASD,GAAM,QAGvDE,eAAiBN,KAAKJ,KAAMQ,GAAQJ,KAAKN,KAAKa,QAAQH,GAAM,QAG5DI,UAAYR,KAAKJ,KAAMQ,GAAQJ,KAAKN,KAAKe,UAAUL,GAAK,GAAO,QAG/DM,gBAAkBV,KAAKJ,KAAMQ,GAAQJ,KAAKN,KAAKiB,SAASP,GAAK,GAAO,QAGpEQ,yBAA2BZ,KAAKJ,KAAMQ,GAAQJ,KAAKN,KAAKiB,SAASP,GAAK,GAAQ,QAG9ES,QAAUb,KAAKJ,KAAMQ,GAAQJ,KAAKN,KAAKoB,SAASV,GAAK,GAAO,QAG5DW,cAAgB,KACd,MAAM3B,EAAU,GAEhB,IAAK,IAAI4B,EAAI,EAAGA,EDtCgB,ICsCUA,IACxC5B,EAAQ6B,KAAKjB,KAAKM,kBAGpB,OAAOlB,QAIT8B,aAAe,KACb,MAAM9B,EAAU,GAChB,KAAOY,KAAKL,SAAWK,KAAKP,KAAK0B,QAC/B/B,EAAQ6B,KAAKjB,KAAKY,4BAEpB,OAAOxB,GAjDPY,KAAKP,KAAOD,EACZQ,KAAKN,KAAO,IAAI0B,SAAS5B,EAAOA,QAChCQ,KAAKL,SAAW,SCRP0B,EAASC,GAChBA,EAAI,IAEGA,GAAK,GACN,EAEDA,EAwBEC,EAAaC,GACT,IAAIlC,EAAakC,GAClBN,eAAeO,IAAKC,GAAW,EAAMA,EAAS,OC5BxDC,EAAoB,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAC5EC,EAAe,CAAC,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,KAChDC,EAAsB,CAAC,IAAK,IAAK,IAAK,IAAK,GAAI,GAAI,GAAI,GACvDC,EAAM,CAAC,EAAG,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAQ/DC,EAAiCC,IACrC,MAAMC,EAAWC,KAAKC,MAAMD,KAAKE,IAAI,GAAIF,KAAKG,IAAI,EAAGL,KAC/CM,EAAmC,IAAvBR,EAAIG,GAAY,KAClC,IAAIM,EAAO,EACPC,EAAQ,EAOZ,OALIF,EAAW,EACbE,EAAQN,KAAKO,IAAI,GAAIH,EAAW,KACvBN,EAAM,IACfO,EAAOL,KAAKO,IAAI,IAAKH,EAAW,MAE3B,CAACC,EAAMC,UAOHE,EAMXnD,YAA6BoD,EAAqBC,QAArBD,wBALZE,uBACAC,mBAEAC,qBAAsB,OAOvCC,iBAAoBC,IAMX,CAAEC,MALKD,EAAOvC,kBAKLyC,WAJGF,EAAO9C,WAIEiD,GAHI,GAArBH,EAAO9C,WAGckD,UAFdJ,EAAOzC,YAEkB8C,MAAO,GAAIC,SAAU,SAGlEC,MAASC,IACP,MAAMR,EAAS,IAAI3D,EAAamE,GAC1BC,EAAc1D,KAAK8C,OAAOrB,IAAKkC,GAAMA,EAAExC,QAE7C8B,EAAOhD,KAAK,GAGZ,MAEM2D,GD1BmBC,ECwBZZ,EAAOzC,YDxBmBsD,EC0BD9D,KAAK2C,YD1BoBoB,GAG1DA,GAFgB7B,KAAKC,MAAM2B,EAAa,KACPD,ICyBhCG,EAAoBJ,EAAW,GD3Bb,IAACC,EAAcC,EC6BvCb,EAAOhD,KAAK,GAEZ,MAAMgE,EAAYL,EAAWX,EAAOpC,WAC9BqD,EAAUN,EAAWX,EAAOpC,WAE5BsD,EAAyB,GAG/B,IAAK,IAAInD,EAAI,EAAGA,EHxES,GGwEUA,IACjCmD,EAAYlD,KAAKjB,KAAKgD,iBAAiBC,IAIzC,IAAK,IAAIjC,EAAI,EAAGA,EH7ES,GG6EUA,IAAK,CAEtC,IAAIoD,EAAY,GACZC,EAAa,EACbC,EAAa,IACbC,EAAU,EAGd,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAYnD,GAAGqC,UAAWmB,IAAK,CACjD,MAAMT,EAAOd,EAAOpC,UACpBsD,EAAYnD,GAAGsC,MAAMrC,KAAK,CAAEwD,MAAOvC,KAAKC,MAAMyB,EAAWG,IAAQW,IAAK,EAAGC,WAAY,EAAGC,YAAa,EAAG5C,IAAK,EAAG6C,MAAO,EAAGC,cAAe,EAAGC,OAAQ,EAAG5D,OAAQ,IAIjK,IAAK,IAAIqD,EAAI,EAAGA,EAAIL,EAAYnD,GAAGqC,UAAWmB,IAAK,CACjD,IAAIK,EAAQ5B,EAAO9C,WACN,KAAT0E,IAAeA,EAAQT,GAC3BA,EAAYS,EACZV,EAAYnD,GAAGsC,MAAMkB,GAAGK,MAAQA,EAIlC,IAAK,IAAIL,EAAI,EAAGA,EAAIL,EAAYnD,GAAGqC,UAAWmB,IAAK,CACjD,IAAIrD,EAAS8B,EAAO9C,WACN,KAAVgB,IAAgBA,EAASkD,GAC7BA,EAAalD,EACbgD,EAAYnD,GAAGsC,MAAMkB,GAAGE,IAAMP,EAAYnD,GAAGsC,MAAMkB,GAAGC,MAAQb,EAAWzC,GACzEgD,EAAYnD,GAAGsC,MAAMkB,GAAGrD,OAASA,EAInC,IAAK,IAAIqD,EAAI,EAAGA,EAAIL,EAAYnD,GAAGqC,UAAWmB,IAAK,CACjD,IAAIO,EAAS9B,EAAO9C,WACN,KAAV4E,IAAgBA,EAAST,GAC7BA,EAAaS,EACbZ,EAAYnD,GAAGsC,MAAMkB,GAAGO,OAASA,EAInC,IAAK,IAAIP,EAAI,EAAGA,EAAIL,EAAYnD,GAAGqC,UAAWmB,IAAK,CACjD,IAAIxC,EAAMiB,EAAO9C,WACN,KAAP6B,IAAaA,EAAMuC,GACvBA,EAAUvC,EACVmC,EAAYnD,GAAGsC,MAAMkB,GAAGxC,IAAMA,EAIhC,IAAK,IAAIwC,EAAI,EAAGA,EAAIL,EAAYnD,GAAGqC,UAAWmB,IAAK,CACjD,MAAMQ,EAAOb,EAAYnD,GAAGsC,MAAMkB,GAC5BK,EAAQG,EAAKH,MACb1F,EAAS6B,GAAK,EAEdiE,EAAYd,EAAYnD,GAAGkC,MHzHM,IG2HvC,IAAIgC,EAAO,EAEX,GAAIlF,KAAK+C,oBAEPmC,EAAOhD,KAAKO,IAAI,GAAIoC,EAAQI,EAAY,SAAW,QAC9C,CAEL,MAAMD,EAAO9C,KAAKC,MAAM0C,EAAQ,IAC1BM,EAASjD,KAAKC,MAAM0C,EAAQ,IAClCK,EAAOvD,EAAkBqD,GAAQpD,EAAauD,IAAWhB,EAAYnD,GAAGkC,MAAQ,KAGlF,MAAMkC,EAAQF,EAAOlF,KAAK2C,aAEnB0C,EAASC,GAAYvD,EAA8BiD,EAAKhD,KACzDuD,EAvILrD,KAAKO,IAAI,GAAsB,GAuIiBuC,EAAKD,OAxIxB,KACO,KA+IrC,GANAC,EAAKL,WAAaU,EAAUE,EAC5BP,EAAKJ,YAAcU,EAAWC,EAE9BP,EAAKF,cAAgBM,EAGjBjG,EAAQ,CAGV6F,EAAKF,eAA8B,IAAbE,EAAKH,MAAc,KAAO7E,KAAK2C,YAGrDqC,EAAKN,IAAMxC,KAAKC,MAAM6C,EAAKP,MAAQvC,KAAKE,IAAIsB,EAAYS,EAAYnD,GAAGmC,YAAc6B,EAAKF,cAAgBd,EAAoBgB,EAAK7D,OAAU6D,EAAKF,gBAGlJ,MAAMU,EAAWrB,EAAYnD,GAAGsC,MAAMkB,EAAI,GACpCgB,IACJR,EAAKN,IAAMxC,KAAKC,MAAMD,KAAKE,IAAI4C,EAAKN,IAAKc,EAASf,MAAQ,KAI9D,GAAIN,EAAYnD,GAAGoC,GAAI,CAErB,MAAM+B,EAASjD,KAAKC,MAAM0C,EAAQ,IAElCG,EAAKN,IAAMM,EAAKP,MADyB,GAAdU,EAAS,GAAStD,EAAoBsD,IAKrEhB,EAAYnD,GAAGsC,MAAMmC,KAAK,CAACC,EAAGC,IAAMD,EAAEjB,MAAQkB,EAAElB,OAGhD,IAAK,IAAID,EAAI,EAAGA,EAAIL,EAAYnD,GAAGqC,UAAWmB,IAAK,CACjD,MAAMjB,EAAWY,EAAYnD,GAAGsC,MAAMsC,UAAWpB,GAAMA,EAAEE,IAAMT,GAI7DE,EAAYnD,GAAGuC,UAFA,GAAbA,EAEwBA,EAEA,GAIhC,MAAO,CAAEsC,aAAc5B,EAAW6B,WAAY5B,EAAS6B,SAAU5B,EAAaL,WAAY9D,KAAK2C,YAAaqD,MAAOhG,KAAK8C,OAAQmD,UAAWjG,KAAK6C,aAzJrH7C,iBAAA2C,EAC3B3C,KAAK6C,WDpBsBqD,CAAAA,IAC7B,MAAMC,EAAc,GACdlD,EAAS,IAAI3D,EAAa4G,GAChC,IAAK,IAAIlF,EAAI,EAAGA,EAAI,IAAKA,IAAK,CAC5B,MAAMoF,EAAsBnD,EAAOlC,gBACnCoF,EAAYlF,KAAKmF,EAAoB3E,IAAK4E,GAAW,EAAMA,EAAS,MAEtE,OAAOF,GCaaG,CAAe1D,EAAS2D,SAC1CvG,KAAK8C,OAASF,EAAS4D,MAAM/E,IAAIF,UC1BxBkF,EAcXlH,YAAYkE,EAAuCb,EAAsCkB,QAAtClB,qBAAsCkB,uBAbxE4C,iBAIAC,WAAyB,CAAC,EAAG,QAC7BC,cAA4B,CAAC,EAAG,QAEzCC,mBACSC,kBAyBjBC,IAAM,CAACC,EAAmBzE,EAAoBC,KAC5C,MAAMhD,EAAS,CAAC,IAAIyH,aAAaD,GAAY,IAAIC,aAAaD,IAE9D,IAAK,IAAIhG,EAAI,EAAGA,EAAIgG,EAAWhG,IAC7BhB,KAAKkH,KAAKlH,KAAK2G,YACfpE,EAAKvB,GAAKhB,KAAK2G,WAAW,GAC1BnE,EAAMxB,GAAKhB,KAAK2G,WAAW,GAG7B,OAAOnH,QAGT0H,KAAQP,IACN,IAAIpE,EAAO,EACPC,EAAQ,EAGZ,IAAK,IAAIxB,EAAI,EAAGA,EAAI,GAAIA,IACtBhB,KAAKmH,YAAYnG,EAAGhB,KAAK4G,eACzBrE,GJnDgC,kBImDxBvC,KAAK4G,cAAc,GAC3BpE,GJpDgC,kBIoDvBxC,KAAK4G,cAAc,GAM9B,GAHA5G,KAAK6G,SAGD7G,KAAK6G,QAAU7G,KAAK0G,KAAKZ,WAAY,CACvC,IAAK,IAAI9E,EAAI,EAAGA,EAAI,GAAIA,IAEtBhB,KAAK8G,MAAM9F,GAAK,CACdoG,UAAWpH,KAAK0G,KAAKX,SAAS/E,GAAGuC,SACjC8D,gBAAiB,EACjBC,cAAe,GAKnBtH,KAAK6G,OAAS7G,KAAK0G,KAAKb,aAE1B,MAAM0B,GLzFgBC,EKyFGxH,KAAK6G,QJzEH,MDdjBW,ECciB,IDhBLA,IAAAA,EK2FtBb,EAAW,GAAKtF,EAAMkB,GAAQgF,EAC9BZ,EAAW,GAAKtF,EAAMmB,GAAS+E,QAGjCJ,YAAc,CAACM,EAAyBb,KACtC,MAAMzD,EAAanD,KAAK0G,KAAKX,SAAS0B,GAChCL,EAAYpH,KAAK8G,MAAMW,GAAiBL,UACxCjI,EAASsI,GAAmB,EAE5BzC,EAAOoC,GAAajE,EAAWG,MAAMnC,OAAS,KAAOgC,EAAWG,MAAM8D,GAE5E,IAAI7E,EAAO,EACPC,EAAQ,EAEZ,GAAY,MAARwC,GAAgBhF,KAAK6G,OAAS7B,EAAKP,MAAO,CAC5C,MAAMrB,GAAEA,GAAOD,EACTuE,EAAavE,EAAWA,WAG9B,IAAKC,GAAMpD,KAAK8G,MAAMW,GAAiBH,cJrGP,KIqG+C,CAC7E,MACMK,EAAyB3H,KAAK8G,MAAMW,GAAiBJ,gBAAkBrC,EAAKF,cAE5E8C,EAAkB5H,KAAK6H,UAHb1I,EAA2Ca,KAAK0G,KAAKV,MAAM0B,GAAlD1H,KAAK0G,KAAKT,UAAUyB,GAGEC,GAE/CpF,EAAOqF,EAAkB5C,EAAKL,WAC9BnC,EAAQoF,EAAkB5C,EAAKJ,YAE/B5E,KAAK8G,MAAMW,GAAiBJ,gBAAkBM,EAC9C3H,KAAK8G,MAAMW,GAAiBH,gBAG5B,MAAMQ,EACJ5I,EAAkBC,EAAQa,KAAK8G,MAAMW,GAAiBH,eL9G9B,EAACnI,EAAiBC,EAAiB+B,IAC5DjC,EAAkBC,EAAQgC,EAAS/B,GK6GqC2I,CAAmB5I,EAAQa,KAAK8G,MAAMW,GAAiBH,cAAetC,EAAKN,IAAMM,EAAKP,OAE/JlC,GAAQuF,EACRtF,GAASsF,GAKD,MAAR9C,GAAgBhF,KAAK6G,QAAU7B,EAAKN,MACtC1E,KAAK8G,MAAMW,GAAiBJ,gBAAkB,EAC9CrH,KAAK8G,MAAMW,GAAiBH,cAAgB,EAC5CtH,KAAK8G,MAAMW,GAAiBL,aAG9BR,EAAc,GAAKrE,EACnBqE,EAAc,GAAKpE,QASrBqF,UAAY,CAACG,EAA2BC,KAEtC,MAAMC,EAAKF,EAAgB9F,KAAKC,MAAM8F,GAAUD,EAAgB7G,QAC1DgH,EAAKH,EAAgB9F,KAAKkG,KAAKH,GAAUD,EAAgB7G,QAE/D,OAAO+G,GADGD,EAAS/F,KAAKC,MAAM8F,KACbE,EAAKD,IA3H2BlI,cAAA4C,EAAsC5C,gBAAA8D,EACvF,MAAMuE,EAAa,IAAI3F,EAAWoB,EAAYlB,GAG9C5C,KAAK0G,KAAO2B,EAAW7E,MAAMC,GAE7BzD,KAAK6G,QAAU,IACf7G,KAAK8G,MAAQ,GACb,IAAK,IAAI9F,EAAI,EAAGA,EAAI,GAAIA,IACtBhB,KAAK8G,MAAM7F,KAAK,CACdmG,UAAW,EACXC,gBAAiB,EACjBC,cAAe"}