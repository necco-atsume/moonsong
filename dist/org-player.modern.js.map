{"version":3,"file":"org-player.modern.js","sources":["../src/envelope.ts","../src/constants.ts","../src/stream.ts","../src/helpers.ts","../src/song-reader.ts","../src/wavetable.ts","../src/org-player.ts"],"sourcesContent":["import { DECAY_TO, DRUM_ENVELOPE_CUTOFF_SAMPLES, ENVELOPE_CUTOFF_SAMPLES, FADE_IN_SAMPLES, USE_ENVELOPE, USE_QUADRATIC_ENVELOPE } from \"./constants\";\r\n\r\nexport const getFadeIn = (absoluteSamples: number): number => {\r\n  if (absoluteSamples > FADE_IN_SAMPLES) return 1.0;\r\n  else return absoluteSamples / FADE_IN_SAMPLES;\r\n};\r\n\r\n// TODO: These are not sample-rate independent!\r\n// Remove some crackling with a really small envelope (100 samples)\r\nexport const getAttackEnvelope = (isDrum: boolean, samples: number): number => {\r\n  if (!USE_ENVELOPE) return 1;\r\n  const cutoff = isDrum ? DRUM_ENVELOPE_CUTOFF_SAMPLES : ENVELOPE_CUTOFF_SAMPLES;\r\n  if (samples > cutoff) return 1.0;\r\n  else {\r\n    if (USE_QUADRATIC_ENVELOPE) {\r\n      let done = samples / cutoff;\r\n      // y = 1 - (1-x) ^ 2 gives us a smooth ramp up.\r\n      return 1 - (Math.pow(1-done, 2));\r\n      // \r\n    } else {\r\n      return samples / cutoff;\r\n    }\r\n  }\r\n};\r\n\r\nexport const getReleaseEnvelope = (isDrum: boolean, samples: number, length: number): number => {\r\n  return getAttackEnvelope(isDrum, length - samples);\r\n};\r\n\r\nexport const getDecayEnvelope = (fadeoffOverSamples: number, samplesPlayed: number): number => {\r\n  if (samplesPlayed > fadeoffOverSamples) return DECAY_TO;\r\n  //else return DECAY_TO + ((samplesPlayed / fadeoffOverSamples) * (1 - DECAY_TO));\r\n  else return 1;\r\n};\r\n\r\n","// Sample rate drums are recorded in - in hz.\r\nexport const DRUM_SAMPLE_RATE = 22050;\r\n\r\n// Number of different channels in the file.\r\nexport const CHANNEL_COUNT = 16;\r\n\r\n// Size of an entry in the wavetable.\r\nexport const WAVETABLE_ENTRY_SIZE = 256;\r\n\r\n// The \"PI\" flag on an instrument sets the length to\r\n// Probably short for 'Pizzacato.'\r\nexport const PI_NOTE_LENGTH_SAMPLES = 1024; // TODO: This is wrong: 'PI' determines how many periods of the wave play.\r\nexport const PITCH_BEND_NORMALIZATION_FACTOR = 1000;\r\nexport const CHANNEL_PRESCALE = 0.5;\r\n\r\nexport const ENVELOPE_CUTOFF_SAMPLES = 50;\r\nexport const DRUM_ENVELOPE_CUTOFF_SAMPLES = 15;\r\n\r\nexport const FADE_IN_SAMPLES = 1000;\r\n\r\nexport const PRE_SCALE_TRACK_VOLUME = 1 / 3;\r\n\r\nexport const USE_ENVELOPE = true;\r\n\r\nexport const USE_QUADRATIC_ENVELOPE = true;\r\n\r\nexport const DECAY_TO = .5;\r\n","import { WAVETABLE_ENTRY_SIZE } from \"./constants\";\r\n\r\n/** Helper array \"stream\" wrapper, for reading the binary .org files. */\r\nexport class BufferStream {\r\n  private readonly data: Uint8Array;\r\n  private readonly view: DataView;\r\n  private position: number;\r\n\r\n  constructor(buffer: Uint8Array) {\r\n    this.data = buffer;\r\n    this.view = new DataView(buffer.buffer);\r\n    this.position = 0;\r\n  }\r\n\r\n  next = (reader: (position: number) => number, size: 1 | 2 | 4) => () => {\r\n    const value = reader(this.position);\r\n    this.position += size;\r\n    return value;\r\n  };\r\n\r\n  /** Skips the next n bytes in the stream. */\r\n  skip = (bytes: number) => (this.position += bytes);\r\n\r\n  /** Reads the next unsigned byte from the stream. */\r\n  nextByte = this.next((pos) => this.view.getUint8(pos), 1);\r\n\r\n  /** Reads the next signed byte from the stream. */\r\n  nextSignedByte = this.next((pos) => this.view.getInt8(pos), 1);\r\n\r\n  /** Reads the next 16 bit integer from the stream, little endian. */\r\n  nextShort = this.next((pos) => this.view.getUint16(pos, true), 2);\r\n\r\n  /** Reads the next signed 16 bit integer from the stream, little endian. */\r\n  nextSignedShort = this.next((pos) => this.view.getInt16(pos, true), 2);\r\n\r\n  /** Reads a big endian signed 16 bit integer from the stream. */\r\n  nextBigEndianSignedShort = this.next((pos) => this.view.getInt16(pos, false), 2);\r\n\r\n  /** Reads the next 32 bit integer from the stream, little endian. */\r\n  nextInt = this.next((pos) => this.view.getInt32(pos, true), 4);\r\n\r\n  /** Reads a whole wavetable from the stream. */\r\n  nextWavetable = (): number[] => {\r\n    const samples = [];\r\n\r\n    for (let i = 0; i < WAVETABLE_ENTRY_SIZE; i++) {\r\n      samples.push(this.nextSignedByte());\r\n    }\r\n\r\n    return samples;\r\n  };\r\n\r\n  /** Reads the whole stream as a drum sample. */\r\n  asDrumSample = (): number[] => {\r\n    const samples = [];\r\n    while (this.position < this.data.length) {\r\n      samples.push(this.nextBigEndianSignedShort());\r\n    }\r\n    return samples;\r\n  };\r\n}\r\n","import { BufferStream } from \"./stream\";\r\n\r\n/** Helper to clamp a value within [-1, 1]. */\r\nexport const clamp = (v: number): number => {\r\n  if (v > 1) {\r\n    return 1;\r\n  } else if (v < -1) {\r\n    return -1;\r\n  } else {\r\n    return v;\r\n  }\r\n};\r\n\r\nexport const parseWavetable = (encodedWavetable: Uint8Array) => {\r\n  const instruments = [];\r\n  const stream = new BufferStream(encodedWavetable);\r\n  for (let i = 0; i < 100; i++) {\r\n    const wavetableInstrument = stream.nextWavetable();\r\n    instruments.push(wavetableInstrument.map((sbyte) => (1.0 * sbyte) / 256.0)); // FIXME: Off-by-one here because this is +127/-128?\r\n  }\r\n  return instruments;\r\n};\r\n\r\nexport const parseDrum = (encodedDrumSample: Uint8Array) => {\r\n  const stream = new BufferStream(encodedDrumSample);\r\n  return stream.asDrumSample().map((short) => (1.0 * short) / 32767.0); // See above: Off by one? a\r\n};\r\n\r\n/** Helper to map from a beat number to a sample number, provided a wait value. */\r\nexport const beatToSample = (wait: number, sampleRate: number) => (beat: number) => {\r\n  const samplesPerMsec = Math.floor(sampleRate / 1000);\r\n  const samplesPerBeat = samplesPerMsec * wait;\r\n  return beat * samplesPerBeat;\r\n};\r\n","import { CHANNEL_COUNT, PITCH_BEND_NORMALIZATION_FACTOR } from \"./constants\";\r\nimport { beatToSample, parseDrum, parseWavetable } from \"./helpers\";\r\nimport { BufferStream } from \"./stream\";\r\nimport { Channel, OrganyaFile } from \"./types\";\r\nimport { WaveTable } from \"./wavetable\";\r\n\r\n// Accurate volume and pan from http://rnhart.net/orgmaker, NXEngine-Evo\r\nconst FrequenciesByNote = [262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494];\r\nconst OctavePeriod = [32, 64, 64, 128, 128, 128, 128, 128];\r\nconst WaveLengthsByOctave = [256, 256, 128, 128, 64, 32, 16, 8];\r\nconst Pan = [0, 43, 86, 129, 172, 215, 256, 297, 340, 383, 426, 469, 512];\r\n\r\nconst getAccurateVolumeScaleFactor = (noteVolume: number): number => {\r\n  // i.cur_vol = powf(10.0, ((event.volume - 255) * 8) / 2000.0) / 128.0;\r\n  const relativeVolume = noteVolume - 255;\r\n  return Math.pow(10, (relativeVolume * 8) / 2000);\r\n};\r\n\r\nconst getAccuratePanningScaleFactor = (pan: number): [number, number] => {\r\n  const panIndex = Math.floor(Math.min(12, Math.max(0, pan)));\r\n  const panValue = (Pan[panIndex] - 256) * 10;\r\n  let left = 1;\r\n  let right = 1;\r\n\r\n  if (panValue < 0) {\r\n    right = Math.pow(10, panValue / 2000);\r\n  } else if (pan > 0) {\r\n    left = Math.pow(10, -panValue / 2000);\r\n  }\r\n  return [left, right];\r\n};\r\n\r\n/**\r\n * Reader which reads a .org file stream in to a parsed song.\r\n * @example `(new SongReader()).read(songData)`;\r\n */\r\nexport class SongReader {\r\n  private readonly _wavetable: number[][];\r\n  private readonly _drums: number[][];\r\n\r\n  private readonly useAlgorithmicPitch = true;\r\n\r\n  constructor(private readonly _sampleRate: number, waveData: WaveTable) {\r\n    this._wavetable = parseWavetable(waveData.WAVE100);\r\n    this._drums = waveData.DRUMS.map(parseDrum);\r\n  }\r\n\r\n  parseChannelData = (stream: BufferStream): Channel => {\r\n    const voice = stream.nextSignedShort();\r\n    const instrument = stream.nextByte();\r\n    const pi = stream.nextByte() != 0;\r\n    const noteCount = stream.nextShort();\r\n\r\n    return { voice, instrument, pi, noteCount, notes: [], loopNote: 0 };\r\n  };\r\n\r\n  parse = (songData: Uint8Array): OrganyaFile => {\r\n    const stream = new BufferStream(songData);\r\n    const drumLengths = this._drums.map((a) => a.length);\r\n\r\n    stream.skip(6); // Header\r\n\r\n    // Wait in msec between beats.\r\n    const wait = stream.nextShort();\r\n\r\n    const sampleTime = beatToSample(wait, this._sampleRate);\r\n    const beatLengthSamples = sampleTime(1);\r\n\r\n    stream.skip(2); // Time signature isn't important for playback.\r\n\r\n    const songStart = sampleTime(stream.nextInt());\r\n    const songEnd = sampleTime(stream.nextInt());\r\n\r\n    const channelData: Channel[] = [];\r\n\r\n    // Read all 16 instrument blocks\r\n    for (let i = 0; i < CHANNEL_COUNT; i++) {\r\n      channelData.push(this.parseChannelData(stream));\r\n    }\r\n\r\n    // Read each of the note blocks for every instrument.\r\n    for (let i = 0; i < CHANNEL_COUNT; i++) {\r\n      // Org format interprets 0xff as what was on the previous note.\r\n      let lastPitch = 95;\r\n      let lastLength = 1;\r\n      let lastVolume = 254;\r\n      let lastPan = 6;\r\n\r\n      // Beat: uint32, start of the note, in beats.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        const beat = stream.nextInt(); // # of beat in the song.\r\n        channelData[i].notes.push({ start: Math.floor(sampleTime(beat)), end: 0, leftVolume: 0, rightVolume: 0, pan: 0, pitch: 0, sampleAdvance: 0, volume: 0, length: 0 });\r\n      }\r\n\r\n      // Pitch\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let pitch = stream.nextByte();\r\n        if (pitch == 0xff) pitch = lastPitch;\r\n        lastPitch = pitch;\r\n        channelData[i].notes[n].pitch = pitch;\r\n      }\r\n\r\n      // Length: uint8, 0-254\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let length = stream.nextByte();\r\n        if (length == 0xff) length = lastLength;\r\n        lastLength = length;\r\n        channelData[i].notes[n].end = channelData[i].notes[n].start + sampleTime(length);\r\n        channelData[i].notes[n].length = length;\r\n      }\r\n\r\n      // Volume: uint8, 0-254.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let volume = stream.nextByte();\r\n        if (volume == 0xff) volume = lastVolume;\r\n        lastVolume = volume;\r\n        channelData[i].notes[n].volume = volume;\r\n      }\r\n\r\n      // Pan: uint8, 0-12.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let pan = stream.nextByte();\r\n        if (pan == 0xff) pan = lastPan;\r\n        lastPan = pan;\r\n        channelData[i].notes[n].pan = pan;\r\n      }\r\n\r\n      // Do some pre-calculations here - get the octave / point speed for the note.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        const note = channelData[i].notes[n];\r\n        const pitch = note.pitch;\r\n        const isDrum = i >= 8;\r\n\r\n        const pitchBend = channelData[i].voice / PITCH_BEND_NORMALIZATION_FACTOR;\r\n\r\n        let freq = 0;\r\n        // Note: frequency algorithm & lookups referenced from: https://github.com/nxengine/nxengine-evo/blob/master/src/sound/Organya.cpp\r\n        if (this.useAlgorithmicPitch) {\r\n          // Algorithmi\r\n          freq = Math.pow(2, (pitch + pitchBend + 155.376) / 12);\r\n        } else {\r\n          // TODO: Figure out what NxEngine's doing here. This is supposed to be \"more accurate\".\r\n          const note = Math.floor(pitch % 12);\r\n          const octave = Math.floor(pitch / 12);\r\n          freq = FrequenciesByNote[note] * OctavePeriod[octave] + (channelData[i].voice - 1000);\r\n        }\r\n\r\n        const speed = freq / this._sampleRate;\r\n\r\n        const [panLeft, panRight] = getAccuratePanningScaleFactor(note.pan);\r\n        const volumeScale = getAccurateVolumeScaleFactor(note.volume);\r\n\r\n        note.leftVolume = panLeft * volumeScale;\r\n        note.rightVolume = panRight * volumeScale;\r\n\r\n        note.sampleAdvance = speed;\r\n\r\n        // And set the correct note length for drum notes.\r\n        if (isDrum) {\r\n          // Also referencing NxEngine here: Drum frequencies are different than instrument ones in a way that's not obvious.\r\n          // And drums don't care about the length? (???)\r\n          note.sampleAdvance = (note.pitch * 800 + 100) / this._sampleRate;\r\n\r\n          // Clip drum length.\r\n          note.end = Math.floor(note.start + Math.min(drumLengths[channelData[i].instrument] / note.sampleAdvance, (beatLengthSamples * note.length) / note.sampleAdvance));\r\n\r\n          // Kill the note early if there's another drum before the end of this one.\r\n          const nextNote = channelData[i].notes[n + 1];\r\n          if (!!nextNote) {\r\n            note.end = Math.floor(Math.min(note.end, nextNote.start - 1));\r\n          }\r\n        }\r\n\r\n        if (channelData[i].pi) {\r\n          // Sourced from: http://rnhart.net/orgmaker/vol-pan-pi.htm & NXEngine-Evo\r\n          const octave = Math.floor(pitch / 12);\r\n          const noteLengthSamples = (octave + 1) * 4 * WaveLengthsByOctave[octave];\r\n          note.end = note.start + noteLengthSamples;\r\n        }\r\n      }\r\n\r\n      channelData[i].notes.sort((l, r) => l.start - r.start); // Sanity check just in case they're not sorted.\r\n\r\n      // Now, calculate loop notes for each of the instruments. When the song loops, it'll set this as the active one.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        const loopNote = channelData[i].notes.findIndex((n) => n.end > songStart);\r\n\r\n        if (loopNote != -1) {\r\n          // Check if we loop _within_ a note. If we do, then play that note.\r\n          channelData[i].loopNote = loopNote;\r\n        } else {\r\n          channelData[i].loopNote = 0;\r\n        }\r\n      }\r\n    }\r\n    return { startSamples: songStart, endSamples: songEnd, channels: channelData, sampleRate: this._sampleRate, drums: this._drums, wavetable: this._wavetable, samplesPerBeat: sampleTime(1) };\r\n  };\r\n}\r\n","const load = async (url: string): Promise<Uint8Array> => {\r\n  const response = await fetch(url);\r\n  const contents = await response.body!.getReader().read();\r\n  return contents!.value!;\r\n};\r\n\r\nexport type WaveTable = {\r\n  WAVE100: Uint8Array;\r\n  DRUMS: readonly Uint8Array[];\r\n};\r\n\r\n/** Helper to, given a base url, pre-load the wave table and drums from a wave100.dat and 100-111.dat files. */\r\nexport const loadWavetableAndDrums = async (baseUrl: string): Promise<WaveTable> => {\r\n  const separator = !baseUrl.endsWith('/') ? '/' : '';\r\n  const path = (name: string) => baseUrl + separator + name;\r\n\r\n  const WAVE100 = await load(path('wave100.dat'));\r\n  const DRUMS: Uint8Array[] = [\r\n    await load(path('100.dat')),\r\n    await load(path('101.dat')),\r\n    await load(path('102.dat')),\r\n    await load(path('103.dat')),\r\n    await load(path('104.dat')),\r\n    await load(path('105.dat')),\r\n    await load(path('106.dat')),\r\n    await load(path('107.dat')),\r\n    await load(path('108.dat')),\r\n    await load(path('109.dat')),\r\n    await load(path('110.dat')),\r\n    await load(path('111.dat')),\r\n  ];\r\n\r\n  return { WAVE100, DRUMS };\r\n};","import { PI_NOTE_LENGTH_SAMPLES, PRE_SCALE_TRACK_VOLUME as PRE_SCALE_CHANNEL_VOLUME } from \"./constants\";\r\nimport { getAttackEnvelope, getDecayEnvelope, getFadeIn, getReleaseEnvelope } from \"./envelope\";\r\nimport { clamp } from \"./helpers\";\r\nimport { SongReader } from \"./song-reader\";\r\nimport { OrganyaFile } from \"./types\";\r\nimport { WaveTable } from \"./wavetable\";\r\n\r\ntype OutputStep = [number, number];\r\n\r\ntype InstrumentState = {\r\n  noteIndex: number;\r\n  wavetableOffset: number;\r\n  samplesPlayed: number;\r\n};\r\n\r\n/**\r\n * .ORG file player. \r\n */\r\nexport class OrganyaPlayer {\r\n  private readonly song: OrganyaFile;\r\n\r\n  // GC optimiztion: Preallocate these to ensure we don't create garbage each step.w\r\n  // (Trying to do all I can to prevent stutter on mobile.)\r\n  private readonly stepBuffer: OutputStep = [0, 0];\r\n  private readonly channelBuffer: OutputStep = [0, 0];\r\n\r\n  private sample: number;\r\n  private readonly state: InstrumentState[];\r\n\r\n  /**\r\n   * Creates a new Organya file player with the given .org file data and sample rate.\r\n   */\r\n  constructor(songData: Uint8Array, private readonly waveData: WaveTable, private readonly sampleRate: number) {\r\n    const songReader = new SongReader(sampleRate, waveData);\r\n\r\n    // TODO: Actually, pass in a Song.\r\n    this.song = songReader.parse(songData);\r\n\r\n    this.sample = -4000; // HACK: Start a bit before the song actually does, to make sure that the browser doesn't stutter.\r\n    this.state = [];\r\n    for (let i = 0; i < 16; i++) {\r\n      this.state.push({\r\n        noteIndex: 0,\r\n        wavetableOffset: 0,\r\n        samplesPlayed: 0,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates the provided number of samples, outputting them into a left / right array.\r\n   */\r\n  run = (stepCount: number, left: Float32Array, right: Float32Array) => {\r\n    const buffer = [new Float32Array(stepCount), new Float32Array(stepCount)];\r\n\r\n    for (let i = 0; i < stepCount; i++) {\r\n      this.step(this.stepBuffer);\r\n      left[i] = this.stepBuffer[0];\r\n      right[i] = this.stepBuffer[1];\r\n    }\r\n\r\n    return buffer;\r\n  };\r\n\r\n  step = (stepBuffer: OutputStep) => {\r\n    let left = 0;\r\n    let right = 0;\r\n\r\n    // Update each instrument.\r\n    for (let i = 0; i < 16; i++) {\r\n      this.stepChannel(i, this.channelBuffer);\r\n      left += this.channelBuffer[0] * PRE_SCALE_CHANNEL_VOLUME;\r\n      right += this.channelBuffer[1] * PRE_SCALE_CHANNEL_VOLUME;\r\n    }\r\n\r\n    this.sample++;\r\n\r\n    // Have we looped around?\r\n    if (this.sample >= this.song.endSamples) {\r\n      for (let i = 0; i < 16; i++) {\r\n        // Reset the sample count & the player states.\r\n        this.state[i] = {\r\n          noteIndex: this.song.channels[i].loopNote,\r\n          wavetableOffset: 0,\r\n          samplesPlayed: 0,\r\n        };\r\n      }\r\n\r\n      // And rewind to the loop point.\r\n      this.sample = this.song.startSamples;\r\n    }\r\n    const fadeIn = getFadeIn(this.sample);\r\n\r\n    stepBuffer[0] = clamp(left) * fadeIn;\r\n    stepBuffer[1] = clamp(right) * fadeIn;\r\n  };\r\n\r\n  stepChannel = (instrumentIndex: number, channelBuffer: OutputStep) => {\r\n    const instrument = this.song.channels[instrumentIndex];\r\n    const noteIndex = this.state[instrumentIndex].noteIndex;\r\n    const isDrum = instrumentIndex >= 8;\r\n\r\n    const note = noteIndex >= instrument.notes.length ? null : instrument.notes[noteIndex];\r\n\r\n    let left = 0;\r\n    let right = 0;\r\n\r\n    if (note != null && this.sample > note.start) {\r\n      const { pi } = instrument;\r\n      const voiceIndex = instrument.instrument;\r\n\r\n      // Play sample.\r\n      if (!pi || this.state[instrumentIndex].samplesPlayed < PI_NOTE_LENGTH_SAMPLES) {\r\n        const sample = !isDrum ? this.song.wavetable[voiceIndex] : this.song.drums[voiceIndex];\r\n        const absoluteSamplePosition = this.state[instrumentIndex].wavetableOffset + note.sampleAdvance;\r\n\r\n        const wavetableSample = this.getSample(sample, absoluteSamplePosition);\r\n\r\n        left = wavetableSample * note.leftVolume;\r\n        right = wavetableSample * note.rightVolume;\r\n\r\n        this.state[instrumentIndex].wavetableOffset = absoluteSamplePosition;\r\n        this.state[instrumentIndex].samplesPlayed++;\r\n\r\n        // Apply a tiny envelope to the instruments, to prevent crackling.\r\n        const envelope_delay = this.song\r\n        const envelope =\r\n          getAttackEnvelope(isDrum, this.state[instrumentIndex].samplesPlayed) \r\n          * getReleaseEnvelope(isDrum, this.state[instrumentIndex].samplesPlayed, note.end - note.start)\r\n          * (isDrum ? 1 : getDecayEnvelope(this.song.samplesPerBeat, this.state[instrumentIndex].samplesPlayed));\r\n\r\n        left *= envelope;\r\n        right *= envelope;\r\n      }\r\n    }\r\n\r\n    // Advance the note index if it's finished playing.\r\n    if (note != null && this.sample >= note.end) {\r\n      this.state[instrumentIndex].wavetableOffset = 0;\r\n      this.state[instrumentIndex].samplesPlayed = 0;\r\n      this.state[instrumentIndex].noteIndex++;\r\n    }\r\n\r\n    channelBuffer[0] = left;\r\n    channelBuffer[1] = right;\r\n  };\r\n/**\r\n   * Reads a single sample from a wavetable or drum sound buffer.\r\n   *\r\n   * @param wavetableOrDrum The sound to read the sample from.\r\n   * @param offset The offset in samples of the sample to read.\r\n   * @returns Returns the sample value (linearly interpolated.)\r\n   */\r\n  getSample = (wavetableOrDrum: number[], offset: number) => {\r\n    // get the lerped value b/w the two samples.\r\n    const v0 = wavetableOrDrum[Math.floor(offset) % wavetableOrDrum.length];\r\n    const v1 = wavetableOrDrum[Math.ceil(offset) % wavetableOrDrum.length];\r\n    const t = offset - Math.floor(offset);\r\n    return v0 + t * (v1 - v0);\r\n  };\r\n}\r\n\r\nexport { WaveTable, loadWavetableAndDrums } from \"./wavetable\";\r\n"],"names":["getAttackEnvelope","isDrum","samples","cutoff","Math","pow","BufferStream","constructor","buffer","data","view","position","next","reader","size","value","this","skip","bytes","nextByte","pos","getUint8","nextSignedByte","getInt8","nextShort","getUint16","nextSignedShort","getInt16","nextBigEndianSignedShort","nextInt","getInt32","nextWavetable","i","push","asDrumSample","length","DataView","clamp","v","parseDrum","encodedDrumSample","map","short","FrequenciesByNote","OctavePeriod","WaveLengthsByOctave","Pan","getAccuratePanningScaleFactor","pan","panIndex","floor","min","max","panValue","left","right","SongReader","_sampleRate","waveData","_wavetable","_drums","useAlgorithmicPitch","parseChannelData","stream","voice","instrument","pi","noteCount","notes","loopNote","parse","songData","drumLengths","a","sampleTime","wait","sampleRate","beat","beatLengthSamples","songStart","songEnd","channelData","lastPitch","lastLength","lastVolume","lastPan","n","start","end","leftVolume","rightVolume","pitch","sampleAdvance","volume","note","pitchBend","freq","octave","speed","panLeft","panRight","volumeScale","nextNote","sort","l","r","findIndex","startSamples","endSamples","channels","drums","wavetable","samplesPerBeat","encodedWavetable","instruments","wavetableInstrument","sbyte","parseWavetable","WAVE100","DRUMS","load","async","response","fetch","url","body","getReader","read","loadWavetableAndDrums","separator","baseUrl","endsWith","path","name","OrganyaPlayer","song","stepBuffer","channelBuffer","sample","state","run","stepCount","Float32Array","step","stepChannel","noteIndex","wavetableOffset","samplesPlayed","fadeIn","absoluteSamples","instrumentIndex","voiceIndex","absoluteSamplePosition","wavetableSample","getSample","envelope","getReleaseEnvelope","wavetableOrDrum","offset","v0","v1","ceil","songReader"],"mappings":"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"}