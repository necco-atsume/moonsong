const t=(t,e)=>{const s=t?15:50;return e>s?1:1-Math.pow(1-e/s,2)};class e{constructor(t){this.data=void 0,this.view=void 0,this.position=void 0,this.next=(t,e)=>()=>{const s=t(this.position);return this.position+=e,s},this.skip=t=>this.position+=t,this.nextByte=this.next(t=>this.view.getUint8(t),1),this.nextSignedByte=this.next(t=>this.view.getInt8(t),1),this.nextShort=this.next(t=>this.view.getUint16(t,!0),2),this.nextSignedShort=this.next(t=>this.view.getInt16(t,!0),2),this.nextBigEndianSignedShort=this.next(t=>this.view.getInt16(t,!1),2),this.nextInt=this.next(t=>this.view.getInt32(t,!0),4),this.nextWavetable=()=>{const t=[];for(let e=0;e<256;e++)t.push(this.nextSignedByte());return t},this.asDrumSample=()=>{const t=[];for(;this.position<this.data.length;)t.push(this.nextBigEndianSignedShort());return t},this.data=t,this.view=new DataView(t.buffer),this.position=0}}const s=t=>t>1?1:t<-1?-1:t,a=t=>new e(t).asDrumSample().map(t=>1*t/32767),n=[262,277,294,311,330,349,370,392,415,440,466,494],i=[32,64,64,128,128,128,128,128],o=[256,256,128,128,64,32,16,8],h=[0,43,86,129,172,215,256,297,340,383,426,469,512],l=t=>{const e=Math.floor(Math.min(12,Math.max(0,t))),s=10*(h[e]-256);let a=1,n=1;return s<0?n=Math.pow(10,s/2e3):t>0&&(a=Math.pow(10,-s/2e3)),[a,n]};class r{constructor(t,s){this._sampleRate=void 0,this._wavetable=void 0,this._drums=void 0,this.useAlgorithmicPitch=!0,this.parseChannelData=t=>({voice:t.nextSignedShort(),instrument:t.nextByte(),pi:0!=t.nextByte(),noteCount:t.nextShort(),notes:[],loopNote:0}),this.parse=t=>{const s=new e(t),a=this._drums.map(t=>t.length);s.skip(6);const h=(p=s.nextShort(),d=this._sampleRate,t=>t*(Math.floor(d/1e3)*p)),r=h(1);var p,d;s.skip(2);const m=h(s.nextInt()),c=h(s.nextInt()),f=[];for(let t=0;t<16;t++)f.push(this.parseChannelData(s));for(let t=0;t<16;t++){let e=95,p=1,d=254,c=6;for(let e=0;e<f[t].noteCount;e++){const e=s.nextInt();f[t].notes.push({start:Math.floor(h(e)),end:0,leftVolume:0,rightVolume:0,pan:0,pitch:0,sampleAdvance:0,volume:0,length:0})}for(let a=0;a<f[t].noteCount;a++){let n=s.nextByte();255==n&&(n=e),e=n,f[t].notes[a].pitch=n}for(let e=0;e<f[t].noteCount;e++){let a=s.nextByte();255==a&&(a=p),p=a,f[t].notes[e].end=f[t].notes[e].start+h(a),f[t].notes[e].length=a}for(let e=0;e<f[t].noteCount;e++){let a=s.nextByte();255==a&&(a=d),d=a,f[t].notes[e].volume=a}for(let e=0;e<f[t].noteCount;e++){let a=s.nextByte();255==a&&(a=c),c=a,f[t].notes[e].pan=a}for(let e=0;e<f[t].noteCount;e++){const s=f[t].notes[e],h=s.pitch,p=t>=8,d=f[t].voice/1e3;let m=0;if(this.useAlgorithmicPitch)m=Math.pow(2,(h+d+155.376)/12);else{const e=Math.floor(h%12),s=Math.floor(h/12);m=n[e]*i[s]+(f[t].voice-1e3)}const c=m/this._sampleRate,[u,v]=l(s.pan),w=Math.pow(10,8*(s.volume-255)/2e3);if(s.leftVolume=u*w,s.rightVolume=v*w,s.sampleAdvance=c,p){s.sampleAdvance=(800*s.pitch+100)/this._sampleRate,s.end=Math.floor(s.start+Math.min(a[f[t].instrument]/s.sampleAdvance,r*s.length/s.sampleAdvance));const n=f[t].notes[e+1];n&&(s.end=Math.floor(Math.min(s.end,n.start-1)))}if(f[t].pi){const t=Math.floor(h/12);s.end=s.start+4*(t+1)*o[t]}}f[t].notes.sort((t,e)=>t.start-e.start);for(let e=0;e<f[t].noteCount;e++){const e=f[t].notes.findIndex(t=>t.end>m);f[t].loopNote=-1!=e?e:0}}return{startSamples:m,endSamples:c,channels:f,sampleRate:this._sampleRate,drums:this._drums,wavetable:this._wavetable,samplesPerBeat:h(1)}},this._sampleRate=t,this._wavetable=(t=>{const s=[],a=new e(t);for(let t=0;t<100;t++){const t=a.nextWavetable();s.push(t.map(t=>1*t/256))}return s})(s.WAVE100),this._drums=s.DRUMS.map(a)}}const p=async t=>{const e=await fetch(t);return(await e.body.getReader().read()).value},d=async t=>{const e=t.endsWith("/")?"":"/",s=s=>t+e+s;return{WAVE100:await p(s("wave100.dat")),DRUMS:[await p(s("100.dat")),await p(s("101.dat")),await p(s("102.dat")),await p(s("103.dat")),await p(s("104.dat")),await p(s("105.dat")),await p(s("106.dat")),await p(s("107.dat")),await p(s("108.dat")),await p(s("109.dat")),await p(s("110.dat")),await p(s("111.dat"))]}};class m{constructor(e,a,n){this.waveData=void 0,this.sampleRate=void 0,this.song=void 0,this.stepBuffer=[0,0],this.channelBuffer=[0,0],this.sample=void 0,this.state=void 0,this.run=(t,e,s)=>{const a=[new Float32Array(t),new Float32Array(t)];for(let a=0;a<t;a++)this.step(this.stepBuffer),e[a]=this.stepBuffer[0],s[a]=this.stepBuffer[1];return a},this.step=t=>{let e=0,a=0;for(let t=0;t<16;t++)this.stepChannel(t,this.channelBuffer),e+=.3333333333333333*this.channelBuffer[0],a+=.3333333333333333*this.channelBuffer[1];if(this.sample++,this.sample>=this.song.endSamples){for(let t=0;t<16;t++)this.state[t]={noteIndex:this.song.channels[t].loopNote,wavetableOffset:0,samplesPlayed:0};this.sample=this.song.startSamples}const n=(i=this.sample)>1e3?1:i/1e3;var i;t[0]=s(e)*n,t[1]=s(a)*n},this.stepChannel=(e,s)=>{const a=this.song.channels[e],n=this.state[e].noteIndex,i=e>=8,o=n>=a.notes.length?null:a.notes[n];let h=0,l=0;if(null!=o&&this.sample>o.start){const{pi:s}=a,n=a.instrument;if(!s||this.state[e].samplesPlayed<1024){const s=this.state[e].wavetableOffset+o.sampleAdvance,a=this.getSample(i?this.song.drums[n]:this.song.wavetable[n],s);h=a*o.leftVolume,l=a*o.rightVolume,this.state[e].wavetableOffset=s,this.state[e].samplesPlayed++;const r=t(i,this.state[e].samplesPlayed)*((e,s,a)=>t(e,a-s))(i,this.state[e].samplesPlayed,o.end-o.start)*(i?1:this.state[e].samplesPlayed>this.song.samplesPerBeat?.5:1);h*=r,l*=r}}null!=o&&this.sample>=o.end&&(this.state[e].wavetableOffset=0,this.state[e].samplesPlayed=0,this.state[e].noteIndex++),s[0]=h,s[1]=l},this.getSample=(t,e)=>{const s=t[Math.floor(e)%t.length],a=t[Math.ceil(e)%t.length];return s+(e-Math.floor(e))*(a-s)},this.waveData=a,this.sampleRate=n;const i=new r(n,a);this.song=i.parse(e),this.sample=-4e3,this.state=[];for(let t=0;t<16;t++)this.state.push({noteIndex:0,wavetableOffset:0,samplesPlayed:0})}}export{m as OrganyaPlayer,d as loadWavetableAndDrums};
//# sourceMappingURL=org-player.modern.js.map
