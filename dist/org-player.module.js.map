{"version":3,"file":"org-player.module.js","sources":["../src/envelope.ts","../src/constants.ts","../src/stream.ts","../src/helpers.ts","../src/song-reader.ts","../src/wavetable.ts","../src/org-player.ts"],"sourcesContent":["import { DECAY_TO, DRUM_ENVELOPE_CUTOFF_SAMPLES, ENVELOPE_CUTOFF_SAMPLES, FADE_IN_SAMPLES, USE_ENVELOPE, USE_QUADRATIC_ENVELOPE } from \"./constants\";\r\n\r\nexport const getFadeIn = (absoluteSamples: number): number => {\r\n  if (absoluteSamples > FADE_IN_SAMPLES) return 1.0;\r\n  else return absoluteSamples / FADE_IN_SAMPLES;\r\n};\r\n\r\n// TODO: These are not sample-rate independent!\r\n// Remove some crackling with a really small envelope (100 samples)\r\nexport const getAttackEnvelope = (isDrum: boolean, samples: number): number => {\r\n  if (!USE_ENVELOPE) return 1;\r\n  const cutoff = isDrum ? DRUM_ENVELOPE_CUTOFF_SAMPLES : ENVELOPE_CUTOFF_SAMPLES;\r\n  if (samples > cutoff) return 1.0;\r\n  else {\r\n    if (USE_QUADRATIC_ENVELOPE) {\r\n      let done = samples / cutoff;\r\n      // y = 1 - (1-x) ^ 2 gives us a smooth ramp up.\r\n      return 1 - (Math.pow(1-done, 2));\r\n      // \r\n    } else {\r\n      return samples / cutoff;\r\n    }\r\n  }\r\n};\r\n\r\nexport const getReleaseEnvelope = (isDrum: boolean, samples: number, length: number): number => {\r\n  return getAttackEnvelope(isDrum, length - samples);\r\n};\r\n\r\nexport const getDecayEnvelope = (fadeoffOverSamples: number, samplesPlayed: number): number => {\r\n  if (samplesPlayed > fadeoffOverSamples) return DECAY_TO;\r\n  //else return DECAY_TO + ((samplesPlayed / fadeoffOverSamples) * (1 - DECAY_TO));\r\n  else return 1;\r\n};\r\n\r\n","// Sample rate drums are recorded in - in hz.\r\nexport const DRUM_SAMPLE_RATE = 22050;\r\n\r\n// Number of different channels in the file.\r\nexport const CHANNEL_COUNT = 16;\r\n\r\n// Size of an entry in the wavetable.\r\nexport const WAVETABLE_ENTRY_SIZE = 256;\r\n\r\n// The \"PI\" flag on an instrument sets the length to\r\n// Probably short for 'Pizzacato.'\r\nexport const PI_NOTE_LENGTH_SAMPLES = 1024; // TODO: This is wrong: 'PI' determines how many periods of the wave play.\r\nexport const PITCH_BEND_NORMALIZATION_FACTOR = 1000;\r\nexport const CHANNEL_PRESCALE = 0.5;\r\n\r\nexport const ENVELOPE_CUTOFF_SAMPLES = 50;\r\nexport const DRUM_ENVELOPE_CUTOFF_SAMPLES = 15;\r\n\r\nexport const FADE_IN_SAMPLES = 1000;\r\n\r\nexport const PRE_SCALE_TRACK_VOLUME = 1 / 3;\r\n\r\nexport const USE_ENVELOPE = true;\r\n\r\nexport const USE_QUADRATIC_ENVELOPE = true;\r\n\r\nexport const DECAY_TO = .5;\r\n","import { WAVETABLE_ENTRY_SIZE } from \"./constants\";\r\n\r\n/** Helper array \"stream\" wrapper, for reading the binary .org files. */\r\nexport class BufferStream {\r\n  private readonly data: Uint8Array;\r\n  private readonly view: DataView;\r\n  private position: number;\r\n\r\n  constructor(buffer: Uint8Array) {\r\n    this.data = buffer;\r\n    this.view = new DataView(buffer.buffer);\r\n    this.position = 0;\r\n  }\r\n\r\n  next = (reader: (position: number) => number, size: 1 | 2 | 4) => () => {\r\n    const value = reader(this.position);\r\n    this.position += size;\r\n    return value;\r\n  };\r\n\r\n  /** Skips the next n bytes in the stream. */\r\n  skip = (bytes: number) => (this.position += bytes);\r\n\r\n  /** Reads the next unsigned byte from the stream. */\r\n  nextByte = this.next((pos) => this.view.getUint8(pos), 1);\r\n\r\n  /** Reads the next signed byte from the stream. */\r\n  nextSignedByte = this.next((pos) => this.view.getInt8(pos), 1);\r\n\r\n  /** Reads the next 16 bit integer from the stream, little endian. */\r\n  nextShort = this.next((pos) => this.view.getUint16(pos, true), 2);\r\n\r\n  /** Reads the next signed 16 bit integer from the stream, little endian. */\r\n  nextSignedShort = this.next((pos) => this.view.getInt16(pos, true), 2);\r\n\r\n  /** Reads a big endian signed 16 bit integer from the stream. */\r\n  nextBigEndianSignedShort = this.next((pos) => this.view.getInt16(pos, false), 2);\r\n\r\n  /** Reads the next 32 bit integer from the stream, little endian. */\r\n  nextInt = this.next((pos) => this.view.getInt32(pos, true), 4);\r\n\r\n  /** Reads a whole wavetable from the stream. */\r\n  nextWavetable = (): number[] => {\r\n    const samples = [];\r\n\r\n    for (let i = 0; i < WAVETABLE_ENTRY_SIZE; i++) {\r\n      samples.push(this.nextSignedByte());\r\n    }\r\n\r\n    return samples;\r\n  };\r\n\r\n  /** Reads the whole stream as a drum sample. */\r\n  asDrumSample = (): number[] => {\r\n    const samples = [];\r\n    while (this.position < this.data.length) {\r\n      samples.push(this.nextBigEndianSignedShort());\r\n    }\r\n    return samples;\r\n  };\r\n}\r\n","import { BufferStream } from \"./stream\";\r\n\r\n/** Helper to clamp a value within [-1, 1]. */\r\nexport const clamp = (v: number): number => {\r\n  if (v > 1) {\r\n    return 1;\r\n  } else if (v < -1) {\r\n    return -1;\r\n  } else {\r\n    return v;\r\n  }\r\n};\r\n\r\nexport const parseWavetable = (encodedWavetable: Uint8Array) => {\r\n  const instruments = [];\r\n  const stream = new BufferStream(encodedWavetable);\r\n  for (let i = 0; i < 100; i++) {\r\n    const wavetableInstrument = stream.nextWavetable();\r\n    instruments.push(wavetableInstrument.map((sbyte) => (1.0 * sbyte) / 256.0)); // FIXME: Off-by-one here because this is +127/-128?\r\n  }\r\n  return instruments;\r\n};\r\n\r\nexport const parseDrum = (encodedDrumSample: Uint8Array) => {\r\n  const stream = new BufferStream(encodedDrumSample);\r\n  return stream.asDrumSample().map((short) => (1.0 * short) / 32767.0); // See above: Off by one? a\r\n};\r\n\r\n/** Helper to map from a beat number to a sample number, provided a wait value. */\r\nexport const beatToSample = (wait: number, sampleRate: number) => (beat: number) => {\r\n  const samplesPerMsec = Math.floor(sampleRate / 1000);\r\n  const samplesPerBeat = samplesPerMsec * wait;\r\n  return beat * samplesPerBeat;\r\n};\r\n","import { CHANNEL_COUNT, PITCH_BEND_NORMALIZATION_FACTOR } from \"./constants\";\r\nimport { beatToSample, parseDrum, parseWavetable } from \"./helpers\";\r\nimport { BufferStream } from \"./stream\";\r\nimport { Channel, OrganyaFile } from \"./types\";\r\nimport { WaveTable } from \"./wavetable\";\r\n\r\n// Accurate volume and pan from http://rnhart.net/orgmaker, NXEngine-Evo\r\nconst FrequenciesByNote = [262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494];\r\nconst OctavePeriod = [32, 64, 64, 128, 128, 128, 128, 128];\r\nconst WaveLengthsByOctave = [256, 256, 128, 128, 64, 32, 16, 8];\r\nconst Pan = [0, 43, 86, 129, 172, 215, 256, 297, 340, 383, 426, 469, 512];\r\n\r\nconst getAccurateVolumeScaleFactor = (noteVolume: number): number => {\r\n  // i.cur_vol = powf(10.0, ((event.volume - 255) * 8) / 2000.0) / 128.0;\r\n  const relativeVolume = noteVolume - 255;\r\n  return Math.pow(10, (relativeVolume * 8) / 2000);\r\n};\r\n\r\nconst getAccuratePanningScaleFactor = (pan: number): [number, number] => {\r\n  const panIndex = Math.floor(Math.min(12, Math.max(0, pan)));\r\n  const panValue = (Pan[panIndex] - 256) * 10;\r\n  let left = 1;\r\n  let right = 1;\r\n\r\n  if (panValue < 0) {\r\n    right = Math.pow(10, panValue / 2000);\r\n  } else if (pan > 0) {\r\n    left = Math.pow(10, -panValue / 2000);\r\n  }\r\n  return [left, right];\r\n};\r\n\r\n/**\r\n * Reader which reads a .org file stream in to a parsed song.\r\n * @example `(new SongReader()).read(songData)`;\r\n */\r\nexport class SongReader {\r\n  private readonly _wavetable: number[][];\r\n  private readonly _drums: number[][];\r\n\r\n  private readonly useAlgorithmicPitch = true;\r\n\r\n  constructor(private readonly _sampleRate: number, waveData: WaveTable) {\r\n    this._wavetable = parseWavetable(waveData.WAVE100);\r\n    this._drums = waveData.DRUMS.map(parseDrum);\r\n  }\r\n\r\n  parseChannelData = (stream: BufferStream): Channel => {\r\n    const voice = stream.nextSignedShort();\r\n    const instrument = stream.nextByte();\r\n    const pi = stream.nextByte() != 0;\r\n    const noteCount = stream.nextShort();\r\n\r\n    return { voice, instrument, pi, noteCount, notes: [], loopNote: 0 };\r\n  };\r\n\r\n  parse = (songData: Uint8Array): OrganyaFile => {\r\n    const stream = new BufferStream(songData);\r\n    const drumLengths = this._drums.map((a) => a.length);\r\n\r\n    stream.skip(6); // Header\r\n\r\n    // Wait in msec between beats.\r\n    const wait = stream.nextShort();\r\n\r\n    const sampleTime = beatToSample(wait, this._sampleRate);\r\n    const beatLengthSamples = sampleTime(1);\r\n\r\n    stream.skip(2); // Time signature isn't important for playback.\r\n\r\n    const songStart = sampleTime(stream.nextInt());\r\n    const songEnd = sampleTime(stream.nextInt());\r\n\r\n    const channelData: Channel[] = [];\r\n\r\n    // Read all 16 instrument blocks\r\n    for (let i = 0; i < CHANNEL_COUNT; i++) {\r\n      channelData.push(this.parseChannelData(stream));\r\n    }\r\n\r\n    // Read each of the note blocks for every instrument.\r\n    for (let i = 0; i < CHANNEL_COUNT; i++) {\r\n      // Org format interprets 0xff as what was on the previous note.\r\n      let lastPitch = 95;\r\n      let lastLength = 1;\r\n      let lastVolume = 254;\r\n      let lastPan = 6;\r\n\r\n      // Beat: uint32, start of the note, in beats.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        const beat = stream.nextInt(); // # of beat in the song.\r\n        channelData[i].notes.push({ start: Math.floor(sampleTime(beat)), end: 0, leftVolume: 0, rightVolume: 0, pan: 0, pitch: 0, sampleAdvance: 0, volume: 0, length: 0 });\r\n      }\r\n\r\n      // Pitch\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let pitch = stream.nextByte();\r\n        if (pitch == 0xff) pitch = lastPitch;\r\n        lastPitch = pitch;\r\n        channelData[i].notes[n].pitch = pitch;\r\n      }\r\n\r\n      // Length: uint8, 0-254\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let length = stream.nextByte();\r\n        if (length == 0xff) length = lastLength;\r\n        lastLength = length;\r\n        channelData[i].notes[n].end = channelData[i].notes[n].start + sampleTime(length);\r\n        channelData[i].notes[n].length = length;\r\n      }\r\n\r\n      // Volume: uint8, 0-254.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let volume = stream.nextByte();\r\n        if (volume == 0xff) volume = lastVolume;\r\n        lastVolume = volume;\r\n        channelData[i].notes[n].volume = volume;\r\n      }\r\n\r\n      // Pan: uint8, 0-12.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let pan = stream.nextByte();\r\n        if (pan == 0xff) pan = lastPan;\r\n        lastPan = pan;\r\n        channelData[i].notes[n].pan = pan;\r\n      }\r\n\r\n      // Do some pre-calculations here - get the octave / point speed for the note.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        const note = channelData[i].notes[n];\r\n        const pitch = note.pitch;\r\n        const isDrum = i >= 8;\r\n\r\n        const pitchBend = channelData[i].voice / PITCH_BEND_NORMALIZATION_FACTOR;\r\n\r\n        let freq = 0;\r\n        // Note: frequency algorithm & lookups referenced from: https://github.com/nxengine/nxengine-evo/blob/master/src/sound/Organya.cpp\r\n        if (this.useAlgorithmicPitch) {\r\n          // Algorithmi\r\n          freq = Math.pow(2, (pitch + pitchBend + 155.376) / 12);\r\n        } else {\r\n          // TODO: Figure out what NxEngine's doing here. This is supposed to be \"more accurate\".\r\n          const note = Math.floor(pitch % 12);\r\n          const octave = Math.floor(pitch / 12);\r\n          freq = FrequenciesByNote[note] * OctavePeriod[octave] + (channelData[i].voice - 1000);\r\n        }\r\n\r\n        const speed = freq / this._sampleRate;\r\n\r\n        const [panLeft, panRight] = getAccuratePanningScaleFactor(note.pan);\r\n        const volumeScale = getAccurateVolumeScaleFactor(note.volume);\r\n\r\n        note.leftVolume = panLeft * volumeScale;\r\n        note.rightVolume = panRight * volumeScale;\r\n\r\n        note.sampleAdvance = speed;\r\n\r\n        // And set the correct note length for drum notes.\r\n        if (isDrum) {\r\n          // Also referencing NxEngine here: Drum frequencies are different than instrument ones in a way that's not obvious.\r\n          // And drums don't care about the length? (???)\r\n          note.sampleAdvance = (note.pitch * 800 + 100) / this._sampleRate;\r\n\r\n          // Clip drum length.\r\n          note.end = Math.floor(note.start + Math.min(drumLengths[channelData[i].instrument] / note.sampleAdvance, (beatLengthSamples * note.length) / note.sampleAdvance));\r\n\r\n          // Kill the note early if there's another drum before the end of this one.\r\n          const nextNote = channelData[i].notes[n + 1];\r\n          if (!!nextNote) {\r\n            note.end = Math.floor(Math.min(note.end, nextNote.start - 1));\r\n          }\r\n        }\r\n\r\n        if (channelData[i].pi) {\r\n          // Sourced from: http://rnhart.net/orgmaker/vol-pan-pi.htm & NXEngine-Evo\r\n          const octave = Math.floor(pitch / 12);\r\n          const noteLengthSamples = (octave + 1) * 4 * WaveLengthsByOctave[octave];\r\n          note.end = note.start + noteLengthSamples;\r\n        }\r\n      }\r\n\r\n      channelData[i].notes.sort((l, r) => l.start - r.start); // Sanity check just in case they're not sorted.\r\n\r\n      // Now, calculate loop notes for each of the instruments. When the song loops, it'll set this as the active one.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        const loopNote = channelData[i].notes.findIndex((n) => n.end > songStart);\r\n\r\n        if (loopNote != -1) {\r\n          // Check if we loop _within_ a note. If we do, then play that note.\r\n          channelData[i].loopNote = loopNote;\r\n        } else {\r\n          channelData[i].loopNote = 0;\r\n        }\r\n      }\r\n    }\r\n    return { startSamples: songStart, endSamples: songEnd, channels: channelData, sampleRate: this._sampleRate, drums: this._drums, wavetable: this._wavetable, samplesPerBeat: sampleTime(1) };\r\n  };\r\n}\r\n","const load = async (url: string): Promise<Uint8Array> => {\r\n  const response = await fetch(url);\r\n  const contents = await response.body!.getReader().read();\r\n  return contents!.value!;\r\n};\r\n\r\nexport type WaveTable = {\r\n  WAVE100: Uint8Array;\r\n  DRUMS: readonly Uint8Array[];\r\n};\r\n\r\n/** Helper to, given a base url, pre-load the wave table and drums from a wave100.dat and 100-111.dat files. */\r\nexport const loadWavetableAndDrums = async (baseUrl: string): Promise<WaveTable> => {\r\n  const separator = !baseUrl.endsWith('/') ? '/' : '';\r\n  const path = (name: string) => baseUrl + separator + name;\r\n\r\n  const WAVE100 = await load(path('wave100.dat'));\r\n  const DRUMS: Uint8Array[] = [\r\n    await load(path('100.dat')),\r\n    await load(path('101.dat')),\r\n    await load(path('102.dat')),\r\n    await load(path('103.dat')),\r\n    await load(path('104.dat')),\r\n    await load(path('105.dat')),\r\n    await load(path('106.dat')),\r\n    await load(path('107.dat')),\r\n    await load(path('108.dat')),\r\n    await load(path('109.dat')),\r\n    await load(path('110.dat')),\r\n    await load(path('111.dat')),\r\n  ];\r\n\r\n  return { WAVE100, DRUMS };\r\n};","import { PI_NOTE_LENGTH_SAMPLES, PRE_SCALE_TRACK_VOLUME as PRE_SCALE_CHANNEL_VOLUME } from \"./constants\";\r\nimport { getAttackEnvelope, getDecayEnvelope, getFadeIn, getReleaseEnvelope } from \"./envelope\";\r\nimport { clamp } from \"./helpers\";\r\nimport { SongReader } from \"./song-reader\";\r\nimport { OrganyaFile } from \"./types\";\r\nimport { WaveTable } from \"./wavetable\";\r\n\r\ntype OutputStep = [number, number];\r\n\r\ntype InstrumentState = {\r\n  noteIndex: number;\r\n  wavetableOffset: number;\r\n  samplesPlayed: number;\r\n};\r\n\r\n/**\r\n * .ORG file player. \r\n */\r\nexport class OrganyaPlayer {\r\n  private readonly song: OrganyaFile;\r\n\r\n  // GC optimiztion: Preallocate these to ensure we don't create garbage each step.w\r\n  // (Trying to do all I can to prevent stutter on mobile.)\r\n  private readonly stepBuffer: OutputStep = [0, 0];\r\n  private readonly channelBuffer: OutputStep = [0, 0];\r\n\r\n  private sample: number;\r\n  private readonly state: InstrumentState[];\r\n\r\n  /**\r\n   * Creates a new Organya file player with the given .org file data and sample rate.\r\n   */\r\n  constructor(songData: Uint8Array, private readonly waveData: WaveTable, private readonly sampleRate: number) {\r\n    const songReader = new SongReader(sampleRate, waveData);\r\n\r\n    // TODO: Actually, pass in a Song.\r\n    this.song = songReader.parse(songData);\r\n\r\n    this.sample = -4000; // HACK: Start a bit before the song actually does, to make sure that the browser doesn't stutter.\r\n    this.state = [];\r\n    for (let i = 0; i < 16; i++) {\r\n      this.state.push({\r\n        noteIndex: 0,\r\n        wavetableOffset: 0,\r\n        samplesPlayed: 0,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates the provided number of samples, outputting them into a left / right array.\r\n   */\r\n  run = (stepCount: number, left: Float32Array, right: Float32Array) => {\r\n    const buffer = [new Float32Array(stepCount), new Float32Array(stepCount)];\r\n\r\n    for (let i = 0; i < stepCount; i++) {\r\n      this.step(this.stepBuffer);\r\n      left[i] = this.stepBuffer[0];\r\n      right[i] = this.stepBuffer[1];\r\n    }\r\n\r\n    return buffer;\r\n  };\r\n\r\n  step = (stepBuffer: OutputStep) => {\r\n    let left = 0;\r\n    let right = 0;\r\n\r\n    // Update each instrument.\r\n    for (let i = 0; i < 16; i++) {\r\n      this.stepChannel(i, this.channelBuffer);\r\n      left += this.channelBuffer[0] * PRE_SCALE_CHANNEL_VOLUME;\r\n      right += this.channelBuffer[1] * PRE_SCALE_CHANNEL_VOLUME;\r\n    }\r\n\r\n    this.sample++;\r\n\r\n    // Have we looped around?\r\n    if (this.sample >= this.song.endSamples) {\r\n      for (let i = 0; i < 16; i++) {\r\n        // Reset the sample count & the player states.\r\n        this.state[i] = {\r\n          noteIndex: this.song.channels[i].loopNote,\r\n          wavetableOffset: 0,\r\n          samplesPlayed: 0,\r\n        };\r\n      }\r\n\r\n      // And rewind to the loop point.\r\n      this.sample = this.song.startSamples;\r\n    }\r\n    const fadeIn = getFadeIn(this.sample);\r\n\r\n    stepBuffer[0] = clamp(left) * fadeIn;\r\n    stepBuffer[1] = clamp(right) * fadeIn;\r\n  };\r\n\r\n  stepChannel = (instrumentIndex: number, channelBuffer: OutputStep) => {\r\n    const instrument = this.song.channels[instrumentIndex];\r\n    const noteIndex = this.state[instrumentIndex].noteIndex;\r\n    const isDrum = instrumentIndex >= 8;\r\n\r\n    const note = noteIndex >= instrument.notes.length ? null : instrument.notes[noteIndex];\r\n\r\n    let left = 0;\r\n    let right = 0;\r\n\r\n    if (note != null && this.sample > note.start) {\r\n      const { pi } = instrument;\r\n      const voiceIndex = instrument.instrument;\r\n\r\n      // Play sample.\r\n      if (!pi || this.state[instrumentIndex].samplesPlayed < PI_NOTE_LENGTH_SAMPLES) {\r\n        const sample = !isDrum ? this.song.wavetable[voiceIndex] : this.song.drums[voiceIndex];\r\n        const absoluteSamplePosition = this.state[instrumentIndex].wavetableOffset + note.sampleAdvance;\r\n\r\n        const wavetableSample = this.getSample(sample, absoluteSamplePosition);\r\n\r\n        left = wavetableSample * note.leftVolume;\r\n        right = wavetableSample * note.rightVolume;\r\n\r\n        this.state[instrumentIndex].wavetableOffset = absoluteSamplePosition;\r\n        this.state[instrumentIndex].samplesPlayed++;\r\n\r\n        // Apply a tiny envelope to the instruments, to prevent crackling.\r\n        const envelope_delay = this.song\r\n        const envelope =\r\n          getAttackEnvelope(isDrum, this.state[instrumentIndex].samplesPlayed) \r\n          * getReleaseEnvelope(isDrum, this.state[instrumentIndex].samplesPlayed, note.end - note.start)\r\n          * (isDrum ? 1 : getDecayEnvelope(this.song.samplesPerBeat, this.state[instrumentIndex].samplesPlayed));\r\n\r\n        left *= envelope;\r\n        right *= envelope;\r\n      }\r\n    }\r\n\r\n    // Advance the note index if it's finished playing.\r\n    if (note != null && this.sample >= note.end) {\r\n      this.state[instrumentIndex].wavetableOffset = 0;\r\n      this.state[instrumentIndex].samplesPlayed = 0;\r\n      this.state[instrumentIndex].noteIndex++;\r\n    }\r\n\r\n    channelBuffer[0] = left;\r\n    channelBuffer[1] = right;\r\n  };\r\n/**\r\n   * Reads a single sample from a wavetable or drum sound buffer.\r\n   *\r\n   * @param wavetableOrDrum The sound to read the sample from.\r\n   * @param offset The offset in samples of the sample to read.\r\n   * @returns Returns the sample value (linearly interpolated.)\r\n   */\r\n  getSample = (wavetableOrDrum: number[], offset: number) => {\r\n    // get the lerped value b/w the two samples.\r\n    const v0 = wavetableOrDrum[Math.floor(offset) % wavetableOrDrum.length];\r\n    const v1 = wavetableOrDrum[Math.ceil(offset) % wavetableOrDrum.length];\r\n    const t = offset - Math.floor(offset);\r\n    return v0 + t * (v1 - v0);\r\n  };\r\n}\r\n\r\nexport { WaveTable, loadWavetableAndDrums } from \"./wavetable\";\r\n"],"names":["getAttackEnvelope","isDrum","samples","cutoff","Math","pow","BufferStream","buffer","data","view","position","next","reader","size","value","_this","skip","bytes","nextByte","this","pos","getUint8","nextSignedByte","getInt8","nextShort","getUint16","nextSignedShort","getInt16","nextBigEndianSignedShort","nextInt","getInt32","nextWavetable","i","push","asDrumSample","length","DataView","clamp","v","parseDrum","encodedDrumSample","map","short","FrequenciesByNote","OctavePeriod","WaveLengthsByOctave","Pan","getAccuratePanningScaleFactor","pan","panIndex","floor","min","max","panValue","left","right","SongReader","_sampleRate","waveData","_wavetable","_drums","useAlgorithmicPitch","parseChannelData","stream","voice","instrument","pi","noteCount","notes","loopNote","parse","songData","drumLengths","a","wait","sampleRate","sampleTime","beat","beatLengthSamples","songStart","songEnd","channelData","lastPitch","lastLength","lastVolume","lastPan","n","start","end","leftVolume","rightVolume","pitch","sampleAdvance","volume","note","freq","octave","speed","panLeft","panRight","volumeScale","nextNote","sort","l","r","findIndex","startSamples","endSamples","channels","drums","wavetable","samplesPerBeat","encodedWavetable","instruments","wavetableInstrument","sbyte","parseWavetable","WAVE100","DRUMS","load","url","fetch","response","body","getReader","read","contents","loadWavetableAndDrums","baseUrl","separator","endsWith","path","name","OrganyaPlayer","song","stepBuffer","channelBuffer","sample","state","run","stepCount","Float32Array","step","stepChannel","noteIndex","wavetableOffset","samplesPlayed","absoluteSamples","fadeIn","instrumentIndex","voiceIndex","absoluteSamplePosition","wavetableSample","getSample","envelope","getReleaseEnvelope","wavetableOrDrum","offset","v0","v1","ceil","songReader"],"mappings":"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"}