{"version":3,"file":"org-player.js","sources":["../src/envelope.ts","../src/constants.ts","../src/stream.ts","../src/helpers.ts","../src/song-reader.ts","../src/wavetable.ts","../src/org-player.ts"],"sourcesContent":["import { DRUM_ENVELOPE_CUTOFF_SAMPLES, ENVELOPE_CUTOFF_SAMPLES, FADE_IN_SAMPLES, USE_ENVELOPE } from \"./constants\";\r\n\r\nexport const getFadeIn = (absoluteSamples: number): number => {\r\n  if (absoluteSamples > FADE_IN_SAMPLES) return 1.0;\r\n  else return absoluteSamples / FADE_IN_SAMPLES;\r\n};\r\n\r\n// TODO: These are not sample-rate independent!\r\n// Remove some crackling with a really small envelope (100 samples)\r\nexport const getAttackEnvelope = (isDrum: boolean, samples: number): number => {\r\n  if (!USE_ENVELOPE) return 1;\r\n  const cutoff = isDrum ? DRUM_ENVELOPE_CUTOFF_SAMPLES : ENVELOPE_CUTOFF_SAMPLES;\r\n  if (samples > cutoff) return 1.0;\r\n  else return samples / cutoff;\r\n};\r\n\r\nexport const getReleaseEnvelope = (isDrum: boolean, samples: number, length: number): number => {\r\n  return getAttackEnvelope(isDrum, length - samples);\r\n};\r\n","// Sample rate drums are recorded in - in hz.\r\nexport const DRUM_SAMPLE_RATE = 22050;\r\n\r\n// Number of different channels in the file.\r\nexport const CHANNEL_COUNT = 16;\r\n\r\n// Size of an entry in the wavetable.\r\nexport const WAVETABLE_ENTRY_SIZE = 256;\r\n\r\n// The \"PI\" flag on an instrument sets the length to\r\n// Probably short for 'Pizzacato.'\r\nexport const PI_NOTE_LENGTH_SAMPLES = 1024; // TODO: This is wrong: 'PI' determines how many periods of the wave play.\r\nexport const PITCH_BEND_NORMALIZATION_FACTOR = 1000;\r\nexport const CHANNEL_PRESCALE = 0.5;\r\n\r\nexport const ENVELOPE_CUTOFF_SAMPLES = 50;\r\nexport const DRUM_ENVELOPE_CUTOFF_SAMPLES = 15;\r\n\r\nexport const FADE_IN_SAMPLES = 1000;\r\n\r\nexport const PRE_SCALE_TRACK_VOLUME = 1 / 3;\r\n\r\nexport const USE_ENVELOPE = true;\r\n","import { WAVETABLE_ENTRY_SIZE } from \"./constants\";\r\n\r\n/** Helper array \"stream\" wrapper, for reading the binary .org files. */\r\nexport class BufferStream {\r\n  private readonly data: Uint8Array;\r\n  private readonly view: DataView;\r\n  private position: number;\r\n\r\n  constructor(buffer: Uint8Array) {\r\n    this.data = buffer;\r\n    this.view = new DataView(buffer.buffer);\r\n    this.position = 0;\r\n  }\r\n\r\n  next = (reader: (position: number) => number, size: 1 | 2 | 4) => () => {\r\n    const value = reader(this.position);\r\n    this.position += size;\r\n    return value;\r\n  };\r\n\r\n  /** Skips the next n bytes in the stream. */\r\n  skip = (bytes: number) => (this.position += bytes);\r\n\r\n  /** Reads the next unsigned byte from the stream. */\r\n  nextByte = this.next((pos) => this.view.getUint8(pos), 1);\r\n\r\n  /** Reads the next signed byte from the stream. */\r\n  nextSignedByte = this.next((pos) => this.view.getInt8(pos), 1);\r\n\r\n  /** Reads the next 16 bit integer from the stream, little endian. */\r\n  nextShort = this.next((pos) => this.view.getUint16(pos, true), 2);\r\n\r\n  /** Reads the next signed 16 bit integer from the stream, little endian. */\r\n  nextSignedShort = this.next((pos) => this.view.getInt16(pos, true), 2);\r\n\r\n  /** Reads a big endian signed 16 bit integer from the stream. */\r\n  nextBigEndianSignedShort = this.next((pos) => this.view.getInt16(pos, false), 2);\r\n\r\n  /** Reads the next 32 bit integer from the stream, little endian. */\r\n  nextInt = this.next((pos) => this.view.getInt32(pos, true), 4);\r\n\r\n  /** Reads a whole wavetable from the stream. */\r\n  nextWavetable = (): number[] => {\r\n    const samples = [];\r\n\r\n    for (let i = 0; i < WAVETABLE_ENTRY_SIZE; i++) {\r\n      samples.push(this.nextSignedByte());\r\n    }\r\n\r\n    return samples;\r\n  };\r\n\r\n  /** Reads the whole stream as a drum sample. */\r\n  asDrumSample = (): number[] => {\r\n    const samples = [];\r\n    while (this.position < this.data.length) {\r\n      samples.push(this.nextBigEndianSignedShort());\r\n    }\r\n    return samples;\r\n  };\r\n}\r\n","import { BufferStream } from \"./stream\";\r\n\r\n/** Helper to clamp a value within [-1, 1]. */\r\nexport const clamp = (v: number): number => {\r\n  if (v > 1) {\r\n    return 1;\r\n  } else if (v < -1) {\r\n    return -1;\r\n  } else {\r\n    return v;\r\n  }\r\n};\r\n\r\nexport const parseWavetable = (encodedWavetable: Uint8Array) => {\r\n  const instruments = [];\r\n  const stream = new BufferStream(encodedWavetable);\r\n  for (let i = 0; i < 100; i++) {\r\n    const wavetableInstrument = stream.nextWavetable();\r\n    instruments.push(wavetableInstrument.map((sbyte) => (1.0 * sbyte) / 256.0)); // FIXME: Off-by-one here because this is +127/-128?\r\n  }\r\n  return instruments;\r\n};\r\n\r\nexport const parseDrum = (encodedDrumSample: Uint8Array) => {\r\n  const stream = new BufferStream(encodedDrumSample);\r\n  return stream.asDrumSample().map((short) => (1.0 * short) / 32767.0); // See above: Off by one? a\r\n};\r\n\r\n/** Helper to map from a beat number to a sample number, provided a wait value. */\r\nexport const beatToSample = (wait: number, sampleRate: number) => (beat: number) => {\r\n  const samplesPerMsec = Math.floor(sampleRate / 1000);\r\n  const samplesPerBeat = samplesPerMsec * wait;\r\n  return beat * samplesPerBeat;\r\n};\r\n","import { CHANNEL_COUNT, PITCH_BEND_NORMALIZATION_FACTOR } from \"./constants\";\r\nimport { beatToSample, parseDrum, parseWavetable } from \"./helpers\";\r\nimport { BufferStream } from \"./stream\";\r\nimport { Channel, OrganyaFile } from \"./types\";\r\nimport { WaveTable } from \"./wavetable\";\r\n\r\n// Accurate volume and pan from http://rnhart.net/orgmaker, NXEngine-Evo\r\nconst FrequenciesByNote = [262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494];\r\nconst OctavePeriod = [32, 64, 64, 128, 128, 128, 128, 128];\r\nconst WaveLengthsByOctave = [256, 256, 128, 128, 64, 32, 16, 8];\r\nconst Pan = [0, 43, 86, 129, 172, 215, 256, 297, 340, 383, 426, 469, 512];\r\n\r\nconst getAccurateVolumeScaleFactor = (noteVolume: number): number => {\r\n  // i.cur_vol = powf(10.0, ((event.volume - 255) * 8) / 2000.0) / 128.0;\r\n  const relativeVolume = noteVolume - 255;\r\n  return Math.pow(10, (relativeVolume * 8) / 2000);\r\n};\r\n\r\nconst getAccuratePanningScaleFactor = (pan: number): [number, number] => {\r\n  const panIndex = Math.floor(Math.min(12, Math.max(0, pan)));\r\n  const panValue = (Pan[panIndex] - 256) * 10;\r\n  let left = 1;\r\n  let right = 1;\r\n\r\n  if (panValue < 0) {\r\n    right = Math.pow(10, panValue / 2000);\r\n  } else if (pan > 0) {\r\n    left = Math.pow(10, -panValue / 2000);\r\n  }\r\n  return [left, right];\r\n};\r\n\r\n/**\r\n * Reader which reads a .org file stream in to a parsed song.\r\n * @example `(new SongReader()).read(songData)`;\r\n */\r\nexport class SongReader {\r\n  private readonly _wavetable: number[][];\r\n  private readonly _drums: number[][];\r\n\r\n  private readonly useAlgorithmicPitch = true;\r\n\r\n  constructor(private readonly _sampleRate: number, waveData: WaveTable) {\r\n    this._wavetable = parseWavetable(waveData.WAVE100);\r\n    this._drums = waveData.DRUMS.map(parseDrum);\r\n  }\r\n\r\n  parseChannelData = (stream: BufferStream): Channel => {\r\n    const voice = stream.nextSignedShort();\r\n    const instrument = stream.nextByte();\r\n    const pi = stream.nextByte() != 0;\r\n    const noteCount = stream.nextShort();\r\n\r\n    return { voice, instrument, pi, noteCount, notes: [], loopNote: 0 };\r\n  };\r\n\r\n  parse = (songData: Uint8Array): OrganyaFile => {\r\n    const stream = new BufferStream(songData);\r\n    const drumLengths = this._drums.map((a) => a.length);\r\n\r\n    stream.skip(6); // Header\r\n\r\n    // Wait in msec between beats.\r\n    const wait = stream.nextShort();\r\n\r\n    const sampleTime = beatToSample(wait, this._sampleRate);\r\n    const beatLengthSamples = sampleTime(1);\r\n\r\n    stream.skip(2); // Time signature isn't important for playback.\r\n\r\n    const songStart = sampleTime(stream.nextInt());\r\n    const songEnd = sampleTime(stream.nextInt());\r\n\r\n    const channelData: Channel[] = [];\r\n\r\n    // Read all 16 instrument blocks\r\n    for (let i = 0; i < CHANNEL_COUNT; i++) {\r\n      channelData.push(this.parseChannelData(stream));\r\n    }\r\n\r\n    // Read each of the note blocks for every instrument.\r\n    for (let i = 0; i < CHANNEL_COUNT; i++) {\r\n      // Org format interprets 0xff as what was on the previous note.\r\n      let lastPitch = 95;\r\n      let lastLength = 1;\r\n      let lastVolume = 254;\r\n      let lastPan = 6;\r\n\r\n      // Beat: uint32, start of the note, in beats.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        const beat = stream.nextInt(); // # of beat in the song.\r\n        channelData[i].notes.push({ start: Math.floor(sampleTime(beat)), end: 0, leftVolume: 0, rightVolume: 0, pan: 0, pitch: 0, sampleAdvance: 0, volume: 0, length: 0 });\r\n      }\r\n\r\n      // Pitch\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let pitch = stream.nextByte();\r\n        if (pitch == 0xff) pitch = lastPitch;\r\n        lastPitch = pitch;\r\n        channelData[i].notes[n].pitch = pitch;\r\n      }\r\n\r\n      // Length: uint8, 0-254\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let length = stream.nextByte();\r\n        if (length == 0xff) length = lastLength;\r\n        lastLength = length;\r\n        channelData[i].notes[n].end = channelData[i].notes[n].start + sampleTime(length);\r\n        channelData[i].notes[n].length = length;\r\n      }\r\n\r\n      // Volume: uint8, 0-254.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let volume = stream.nextByte();\r\n        if (volume == 0xff) volume = lastVolume;\r\n        lastVolume = volume;\r\n        channelData[i].notes[n].volume = volume;\r\n      }\r\n\r\n      // Pan: uint8, 0-12.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        let pan = stream.nextByte();\r\n        if (pan == 0xff) pan = lastPan;\r\n        lastPan = pan;\r\n        channelData[i].notes[n].pan = pan;\r\n      }\r\n\r\n      // Do some pre-calculations here - get the octave / point speed for the note.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        const note = channelData[i].notes[n];\r\n        const pitch = note.pitch;\r\n        const isDrum = i >= 8;\r\n\r\n        const pitchBend = channelData[i].voice / PITCH_BEND_NORMALIZATION_FACTOR;\r\n\r\n        let freq = 0;\r\n        // Note: frequency algorithm & lookups referenced from: https://github.com/nxengine/nxengine-evo/blob/master/src/sound/Organya.cpp\r\n        if (this.useAlgorithmicPitch) {\r\n          // Algorithmi\r\n          freq = Math.pow(2, (pitch + pitchBend + 155.376) / 12);\r\n        } else {\r\n          // TODO: Figure out what NxEngine's doing here. This is supposed to be \"more accurate\".\r\n          const note = Math.floor(pitch % 12);\r\n          const octave = Math.floor(pitch / 12);\r\n          freq = FrequenciesByNote[note] * OctavePeriod[octave] + (channelData[i].voice - 1000);\r\n        }\r\n\r\n        const speed = freq / this._sampleRate;\r\n\r\n        const [panLeft, panRight] = getAccuratePanningScaleFactor(note.pan);\r\n        const volumeScale = getAccurateVolumeScaleFactor(note.volume);\r\n\r\n        note.leftVolume = panLeft * volumeScale;\r\n        note.rightVolume = panRight * volumeScale;\r\n\r\n        note.sampleAdvance = speed;\r\n\r\n        // And set the correct note length for drum notes.\r\n        if (isDrum) {\r\n          // Also referencing NxEngine here: Drum frequencies are different than instrument ones in a way that's not obvious.\r\n          // And drums don't care about the length? (???)\r\n          note.sampleAdvance = (note.pitch * 800 + 100) / this._sampleRate;\r\n\r\n          // Clip drum length.\r\n          note.end = Math.floor(note.start + Math.min(drumLengths[channelData[i].instrument] / note.sampleAdvance, (beatLengthSamples * note.length) / note.sampleAdvance));\r\n\r\n          // Kill the note early if there's another drum before the end of this one.\r\n          const nextNote = channelData[i].notes[n + 1];\r\n          if (!!nextNote) {\r\n            note.end = Math.floor(Math.min(note.end, nextNote.start - 1));\r\n          }\r\n        }\r\n\r\n        if (channelData[i].pi) {\r\n          // Sourced from: http://rnhart.net/orgmaker/vol-pan-pi.htm & NXEngine-Evo\r\n          const octave = Math.floor(pitch / 12);\r\n          const noteLengthSamples = (octave + 1) * 4 * WaveLengthsByOctave[octave];\r\n          note.end = note.start + noteLengthSamples;\r\n        }\r\n      }\r\n\r\n      channelData[i].notes.sort((l, r) => l.start - r.start); // Sanity check just in case they're not sorted.\r\n\r\n      // Now, calculate loop notes for each of the instruments. When the song loops, it'll set this as the active one.\r\n      for (let n = 0; n < channelData[i].noteCount; n++) {\r\n        const loopNote = channelData[i].notes.findIndex((n) => n.end > songStart);\r\n\r\n        if (loopNote != -1) {\r\n          // Check if we loop _within_ a note. If we do, then play that note.\r\n          channelData[i].loopNote = loopNote;\r\n        } else {\r\n          channelData[i].loopNote = 0;\r\n        }\r\n      }\r\n    }\r\n    return { startSamples: songStart, endSamples: songEnd, channels: channelData, sampleRate: this._sampleRate, drums: this._drums, wavetable: this._wavetable };\r\n  };\r\n}\r\n","const load = async (url: string): Promise<Uint8Array> => {\r\n  const response = await fetch(url);\r\n  const contents = await response.body.getReader().read();\r\n  return contents.value!;\r\n};\r\n\r\nexport type WaveTable = {\r\n  WAVE100: Uint8Array;\r\n  DRUMS: readonly Uint8Array[];\r\n};\r\n\r\n/** Helper to, given a base url, pre-load the wave table and drums from a wave100.dat and 100-111.dat files. */\r\nexport const loadWavetableAndDrums = async (baseUrl: string): Promise<WaveTable> => {\r\n  const separator = !baseUrl.endsWith('/') ? '/' : '';\r\n  const path = (name: string) => baseUrl + separator + name;\r\n\r\n  const WAVE100 = await load(path('wave100.dat'));\r\n  const DRUMS: Uint8Array[] = [\r\n    await load(path('100.dat')),\r\n    await load(path('101.dat')),\r\n    await load(path('102.dat')),\r\n    await load(path('103.dat')),\r\n    await load(path('104.dat')),\r\n    await load(path('105.dat')),\r\n    await load(path('106.dat')),\r\n    await load(path('107.dat')),\r\n    await load(path('108.dat')),\r\n    await load(path('109.dat')),\r\n    await load(path('110.dat')),\r\n    await load(path('111.dat')),\r\n  ];\r\n\r\n  return { WAVE100, DRUMS };\r\n};","import { PI_NOTE_LENGTH_SAMPLES, PRE_SCALE_TRACK_VOLUME as PRE_SCALE_CHANNEL_VOLUME } from \"./constants\";\r\nimport { getAttackEnvelope, getFadeIn, getReleaseEnvelope } from \"./envelope\";\r\nimport { clamp } from \"./helpers\";\r\nimport { SongReader } from \"./song-reader\";\r\nimport { OrganyaFile } from \"./types\";\r\nimport { WaveTable } from \"./wavetable\";\r\n\r\ntype OutputStep = [number, number];\r\n\r\ntype InstrumentState = {\r\n  noteIndex: number;\r\n  wavetableOffset: number;\r\n  samplesPlayed: number;\r\n};\r\n\r\n/**\r\n * .ORG file player. \r\n */\r\nexport class OrganyaPlayer {\r\n  private readonly song: OrganyaFile;\r\n\r\n  // GC optimiztion: Preallocate these to ensure we don't create garbage each step.w\r\n  // (Trying to do all I can to prevent stutter on mobile.)\r\n  private readonly stepBuffer: OutputStep = [0, 0];\r\n  private readonly channelBuffer: OutputStep = [0, 0];\r\n\r\n  private sample: number;\r\n  private readonly state: InstrumentState[];\r\n\r\n  /**\r\n   * Creates a new Organya file player with the given .org file data and sample rate.\r\n   */\r\n  constructor(songData: Uint8Array, private readonly waveData: WaveTable, private readonly sampleRate: number) {\r\n    const songReader = new SongReader(sampleRate, waveData);\r\n\r\n    // TODO: Actually, pass in a Song.\r\n    this.song = songReader.parse(songData);\r\n\r\n    this.sample = -4000; // HACK: Start a bit before the song actually does, to make sure that the browser doesn't stutter.\r\n    this.state = [];\r\n    for (let i = 0; i < 16; i++) {\r\n      this.state.push({\r\n        noteIndex: 0,\r\n        wavetableOffset: 0,\r\n        samplesPlayed: 0,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates the provided number of samples, outputting them into a left / right array.\r\n   */\r\n  run = (stepCount: number, left: Float32Array, right: Float32Array) => {\r\n    const buffer = [new Float32Array(stepCount), new Float32Array(stepCount)];\r\n\r\n    for (let i = 0; i < stepCount; i++) {\r\n      this.step(this.stepBuffer);\r\n      left[i] = this.stepBuffer[0];\r\n      right[i] = this.stepBuffer[1];\r\n    }\r\n\r\n    return buffer;\r\n  };\r\n\r\n  step = (stepBuffer: OutputStep) => {\r\n    let left = 0;\r\n    let right = 0;\r\n\r\n    // Update each instrument.\r\n    for (let i = 0; i < 16; i++) {\r\n      this.stepChannel(i, this.channelBuffer);\r\n      left += this.channelBuffer[0] * PRE_SCALE_CHANNEL_VOLUME;\r\n      right += this.channelBuffer[1] * PRE_SCALE_CHANNEL_VOLUME;\r\n    }\r\n\r\n    this.sample++;\r\n\r\n    // Have we looped around?\r\n    if (this.sample >= this.song.endSamples) {\r\n      for (let i = 0; i < 16; i++) {\r\n        // Reset the sample count & the player states.\r\n        this.state[i] = {\r\n          noteIndex: this.song.channels[i].loopNote,\r\n          wavetableOffset: 0,\r\n          samplesPlayed: 0,\r\n        };\r\n      }\r\n\r\n      // And rewind to the loop point.\r\n      this.sample = this.song.startSamples;\r\n    }\r\n    const fadeIn = getFadeIn(this.sample);\r\n\r\n    stepBuffer[0] = clamp(left) * fadeIn;\r\n    stepBuffer[1] = clamp(right) * fadeIn;\r\n  };\r\n\r\n  stepChannel = (instrumentIndex: number, channelBuffer: OutputStep) => {\r\n    const instrument = this.song.channels[instrumentIndex];\r\n    const noteIndex = this.state[instrumentIndex].noteIndex;\r\n    const isDrum = instrumentIndex >= 8;\r\n\r\n    const note = noteIndex >= instrument.notes.length ? null : instrument.notes[noteIndex];\r\n\r\n    let left = 0;\r\n    let right = 0;\r\n\r\n    if (note != null && this.sample > note.start) {\r\n      const { pi } = instrument;\r\n      const voiceIndex = instrument.instrument;\r\n\r\n      // Play sample.\r\n      if (!pi || this.state[instrumentIndex].samplesPlayed < PI_NOTE_LENGTH_SAMPLES) {\r\n        const sample = !isDrum ? this.song.wavetable[voiceIndex] : this.song.drums[voiceIndex];\r\n        const absoluteSamplePosition = this.state[instrumentIndex].wavetableOffset + note.sampleAdvance;\r\n\r\n        const wavetableSample = this.getSample(sample, absoluteSamplePosition);\r\n\r\n        left = wavetableSample * note.leftVolume;\r\n        right = wavetableSample * note.rightVolume;\r\n\r\n        this.state[instrumentIndex].wavetableOffset = absoluteSamplePosition;\r\n        this.state[instrumentIndex].samplesPlayed++;\r\n\r\n        // Apply a tiny envelope to the instruments, to prevent crackling.\r\n        const envelope =\r\n          getAttackEnvelope(isDrum, this.state[instrumentIndex].samplesPlayed) * getReleaseEnvelope(isDrum, this.state[instrumentIndex].samplesPlayed, note.end - note.start);\r\n\r\n        left *= envelope;\r\n        right *= envelope;\r\n      }\r\n    }\r\n\r\n    // Advance the note index if it's finished playing.\r\n    if (note != null && this.sample >= note.end) {\r\n      this.state[instrumentIndex].wavetableOffset = 0;\r\n      this.state[instrumentIndex].samplesPlayed = 0;\r\n      this.state[instrumentIndex].noteIndex++;\r\n    }\r\n\r\n    channelBuffer[0] = left;\r\n    channelBuffer[1] = right;\r\n  };\r\n/**\r\n   * Reads a single sample from a wavetable or drum sound buffer.\r\n   *\r\n   * @param wavetableOrDrum The sound to read the sample from.\r\n   * @param offset The offset in samples of the sample to read.\r\n   * @returns Returns the sample value (linearly interpolated.)\r\n   */\r\n  getSample = (wavetableOrDrum: number[], offset: number) => {\r\n    // get the lerped value b/w the two samples.\r\n    const v0 = wavetableOrDrum[Math.floor(offset) % wavetableOrDrum.length];\r\n    const v1 = wavetableOrDrum[Math.ceil(offset) % wavetableOrDrum.length];\r\n    const t = offset - Math.floor(offset);\r\n    return v0 + t * (v1 - v0);\r\n  };\r\n}\r\n\r\nexport { WaveTable, loadWavetableAndDrums } from \"./wavetable\";\r\n"],"names":["getAttackEnvelope","isDrum","samples","cutoff","BufferStream","buffer","data","view","position","next","reader","size","value","_this","skip","bytes","nextByte","this","pos","getUint8","nextSignedByte","getInt8","nextShort","getUint16","nextSignedShort","getInt16","nextBigEndianSignedShort","nextInt","getInt32","nextWavetable","i","push","asDrumSample","length","DataView","clamp","v","parseDrum","encodedDrumSample","map","short","FrequenciesByNote","OctavePeriod","WaveLengthsByOctave","Pan","getAccuratePanningScaleFactor","pan","panIndex","Math","floor","min","max","panValue","left","right","pow","SongReader","_sampleRate","waveData","_wavetable","_drums","useAlgorithmicPitch","parseChannelData","stream","voice","instrument","pi","noteCount","notes","loopNote","parse","songData","drumLengths","a","wait","sampleRate","sampleTime","beat","beatLengthSamples","songStart","songEnd","channelData","lastPitch","lastLength","lastVolume","lastPan","n","start","end","leftVolume","rightVolume","pitch","sampleAdvance","volume","note","freq","octave","speed","panLeft","panRight","volumeScale","nextNote","sort","l","r","findIndex","startSamples","endSamples","channels","drums","wavetable","encodedWavetable","instruments","wavetableInstrument","sbyte","parseWavetable","WAVE100","DRUMS","load","url","fetch","response","body","getReader","read","contents","song","stepBuffer","channelBuffer","sample","state","run","stepCount","Float32Array","step","stepChannel","noteIndex","wavetableOffset","samplesPlayed","absoluteSamples","fadeIn","instrumentIndex","voiceIndex","absoluteSamplePosition","wavetableSample","getSample","envelope","getReleaseEnvelope","wavetableOrDrum","offset","v0","v1","ceil","songReader","baseUrl","separator","endsWith","path","name"],"mappings":"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"}